#!/usr/bin/env bash

# system_info.sh
# Written by:   Ken Cormack, unixken@yahoo.com
# Copyright (c) 2020, Ken Cormack
# github:       https://github.com/kencormack/system_info
# license:      GPL 3.0
# Contributor:  William Stearns, william.l.stearns@gmail.com
#
# This script attempts to perform a fairly complete audit of the current
# configuration of a Raspberry Pi.  The target hardware is any variant or
# model of Pi, up to and including the Pi 4B in all it's available memory
# configurations (1-8GB).  Supported OS versions include Raspbian Stretch
# and Buster (including the newly renamed "Raspberry Pi OS", in 32-bit and
# 64-bit).  Expect things to not work on the 64-bit OS, while it is still
# beta.  No attempts will be made to back-port this to Jessie or older.
#
# The script is an "examination only" affair, making no attempts to add,
# delete, or change anything on the system.
#
# This script does not attempt to configure things for you, nor does it
# make any recommendations on config changes that should be made.  It ONLY
# reports what you currently have going on, with your system.  It is entirely
# YOUR responsibility to do the research needed, to properly set up your
# system.
#
# The intended audience for this script is any Pi user who wants to see how
# aspects of their Pi are currently equipped and configured, for general
# troubleshooting, confirmation, or education/curiosity purposes.  It does
# nothing that hasn't already been done by any/all of the tools it calls upon.
# I'm just consolidating everything into one place.  Deliberate attempts were
# made to make things easy to follow, and the coding style is meant for easy
# readability.
#
# 'sudo' access is required.  The script can be run as the user, and will
# call sudo only for those commands that need root privilege.
#
# The following packages are required, to do a basic inspection:
#   alsa-utils, bc, bluez, coreutils, cron, i2c-tools, initramfs-tools, iproute2,
#   util-linux, v4l-utils, libraspberrypi-bin, lshw, net-tools, procps, rpi-eeprom,
#   usbutils, sed, wireless-tools
#
# If the Pi being examined is a 4B, the package rpi-eeprom is also required.
#
# The script will explicitly test that each of those packages is installed.
# If any are missing, it will inform the user, and instruct them to install.
#
# The following supplemental packages may also be utilized:
#   apparmor, at, auditd, chkrootkit, clamav, cups-client, dc, docker-ce-cli,
#   ethtool, hdparm, lirc, lm-sensors, lvm2, lynis, m4, mdadm, nfs-kernel-server,
#   nmap, perl-base, pigpiod, python3-gpiozero, quota, rkhunter, rng-tools, rpcbind,
#   rtl-sdr, samba, smartmontools, snort, sysbench, sysstat, systemd-container,
#   systemd-coredump, tripwire, ufw, unhide, watchdog, wiringpi, x11-xserver-utils
#
# NOTE:
# If you have a raspberry pi 4B (1/2/4GB only), install version 2.52 of wiringpi
# See - http://wiringpi.com/wiringpi-updated-to-2-52-for-the-raspberry-pi-4b/
# As WiringPi is now deprecated, this script will NOT support WiringPi on the
# Pi 4B 8GB model.
#
# The supplemental packages are not required, and the user will not be
# instructed to install them.  But they will be utilized if installed and
# configured.  Sections of the output made possible by the supplemental packages
# will bee marked with (***) in the heading of any sections involved, or in the
# part of an otherwise core test that has made use of the supplemental package.
#
# See the README.md for further information.
##################################################

#---------------
# Called by fnMAIN
fnINITIALIZE()
{
  trap fnABORT SIGHUP SIGINT SIGQUIT SIGABRT SIGTERM

  # Indexed arrays
  declare -a CHOICES
  declare -a OPTIONS

  PATH="${PATH}:/sbin:/usr/sbin"
  LC_ALL=C
  LANG=C
  if [[ "${TERM}" = "" ]] || [[ "${TERM}" = "dumb" ]]
  then
    REV=""
    SGR0=""
    BELL=""
  else
    REV="$(tput rev 2>/dev/null)"
    SGR0="$(tput sgr0 2>/dev/null)"
    BELL="$(tput bel 2>/dev/null)"
  fi
  RCFILE="${HOME}/.system_inforc"
  ERROR=" "
  DEG_SYMBOL=$'\xc2\xb0'
}

#---------------
# Called by fnMAIN
fnDEFINE_OPTIONS()
{
  # The array of menu OPTIONS is defined
  OPTIONS[0]="Pi Hardware"
  OPTIONS[1]="Performance"
  OPTIONS[2]="O/S Config"
  OPTIONS[3]="Memory"
  OPTIONS[4]="Logging"
  OPTIONS[5]="Services"
  OPTIONS[6]="Hardware Busses"
  OPTIONS[7]="Serial & Bluetooth"
  OPTIONS[8]="USB & Other Devices"
  OPTIONS[9]="Filesystems & Storage"
  OPTIONS[10]="Audio & Video"
  OPTIONS[11]="Networking"
  OPTIONS[12]="Network Filesystems"
  OPTIONS[13]="Containers & Virtualization"
  OPTIONS[14]="Modules and Packages"
  OPTIONS[15]="System Security"
  OPTIONS[16]="Run All Of The Above"
}

#---------------
# Called by fnMAIN
fnCONFIRM_BASH()
{
  # This guards against people launching this script with an incorrect shell,
  # such as by running 'sh scriptname', overriding the 'shebang' (#!/bin/bash).
  if [[ "${BASH_VERSION}" = "" ]]
  then
    echo "${BELL}"
    clear
    echo "################################################################"
    echo
    echo "ERROR: THE WRONG SHELL IS BEING USED TO RUN THIS SCRIPT."
    echo
    echo "${0} is written for the bash shell only."
    echo "It will not run under sh, ksh, or any other shell but bash."
    echo
    echo "Please do either this..."
    echo "  $ chmod +x ${0}"
    echo "  $ ${0}"
    echo
    echo "or this..."
    echo "  $ bash ${0}"
    echo
    echo "...to execute under bash, as intended."
    echo
    echo "################################################################"
    echo
    exit
  fi
}

#---------------
# Called by fnINITIALIZE
fnABORT()
{
  echo
  echo "ABORT${BELL}"
  rm /tmp/.lshw_businfo.${PPID} 2>/dev/null
  exit
}

#---------------
# Called by fnMAIN and fnDO_INSPECTIONS
fnTITLE()
{
  echo
  echo "               _   VERSION ${MY_VERSION}   _        __"
  echo " ___ _   _ ___| |_ ___ _ __ ___   (_)_ __  / _| ___"
  echo "/ __| | | / __| __/ _ \\ '_ \` _ \\  | | '_ \\| |_ / _ \\"
  echo "\__ \ |_| \__ \ ||  __/ | | | | | | | | | |  _| (_) |"
  echo "|___/\__, |___/\__\___|_| |_| |_| |_|_| |_|_|  \___/"
  echo "     |___/"
  echo "           RASPBERRY PI SYSTEM INFORMATION REPORT"
  echo
}

#---------------
# Called by multiple functions
fnBANNER()
{
  echo "==============================================================================="
  echo "SYSTEM_INFO${MENU_OPTION}:${*}"
  echo "==============================================================================="
  echo
}

#---------------
# Called by multiple functions
fnSUB_BANNER()
{
  echo "-------------------------------------------------------"
  echo "${@}"
  echo
}

#---------------
# Inspect the mode (permissions - in octal), owner, and group of a specified directory or file.
# Called by passing 4 parameters to the function as follows:
# fnMOG octal_mode owner group directory
# Called by fnUSERCHECK and fnCHECK_PERMISSIONS
fnMOG()
{
  local OCTAL
  local OWNER
  local GROUP
  local CHECKPATH
  local COCTAL
  local SYMBOLIC
  local COWNER
  local CGROUP

  OCTAL="${1}"      # recommended perms, eg: 755 (rwxr-xr-x)
  OWNER="${2}"      # recommended owner
  GROUP="${3}"      # recommended group
  CHECKPATH="${4}"  # path to check

  if [[ -e "${CHECKPATH}" ]]
  then
    # Run commands
    COCTAL="$(${SUDO} stat -L -c %a "${CHECKPATH}")"
    SYMBOLIC="$(${SUDO} stat -L -c %A "${CHECKPATH}")"
    COWNER="$(${SUDO} stat -L -c %U "${CHECKPATH}")"
    CGROUP="$(${SUDO} stat -L -c %G "${CHECKPATH}")"
    # Compare
    echo "[${CHECKPATH}]"
    if [[ "${COCTAL}" != "${OCTAL}" ]]
    then
      echo "  Permissions ... WARN [${COCTAL}] (${SYMBOLIC}) - Recommend [${OCTAL}])"
    else
      echo "  Permissions ... OK [${OCTAL}] (${SYMBOLIC})"
    fi
    if [[ "${COWNER}" != "${OWNER}" ]]
    then
      echo "  Owner ......... WARN [${COWNER}] - Recommend [${OWNER}]"
    else
      echo "  Owner ......... OK [${OWNER}]"
    fi
    if [[ "${CGROUP}" != "${GROUP}" ]]
    then
      echo "  Group ......... WARN [${CGROUP}] - Recommend [${GROUP}]"
    else
      echo "  Group ......... OK [${GROUP}]"
    fi
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnBANNER
fnCONFIRM_OS()
{
  # Written for Raspbian Stretch and above.  Jessie and older are not supported.
  # if os-release file exists...
  if [[ -f /etc/os-release ]]
  then
    # source the os-release file
    . /etc/os-release 2>/dev/null
    # if Raspbian...
    if [[ "${ID}" = "raspbian" ]]
    then
      # and if older than Stretch...
      if [[ "$(echo "${VERSION_ID} < 9" | bc)" -eq 1 ]]
      then
        # too old.
        echo
        fnBANNER " UNSUPPORTED RASPBIAN VERSION"
        echo "This script is designed for Raspbian GNU/Linux 9 (Stretch), and above."
        echo "Version ${PRETTY_NAME} is not supported."
        echo
        exit 1
      else
        # if Raspbian, and Stretch or newer, then ok.
        echo "OS version check:  ok"
      fi
    else
      # if not Raspbian, then unsupported.
      echo
      fnBANNER " LINUX VERSION UNKNOWN"
      echo "This script is designed for Raspbian GNU/Linux 9 (Stretch), and above."
      echo "Unable to identify your version of the operating system... Exiting."
      echo
      exit 1
    fi
  else
    # if os-release file doesn't exist...
    echo
    fnBANNER " LINUX VERSION UNKNOWN"
    echo "This script is designed for Raspbian GNU/Linux 9 (Stretch), and above."
    echo "Unable to identify your version of the operating system... Exiting."
    echo
    exit 1
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnBANNER
fnRING_BUF()
{
  # Check that dmesg contains anything we might need.  Examples include the
  # "memory split", "active display driver", "rtc", and several other tests.
  if [[ "$(dmesg | grep "Booting Linux")" = "" ]]
  then
    echo
    fnBANNER " DMESG RING BUFFER HAS WRAPPED - PLEASE REBOOT"
    echo "This script relies on \"dmesg\" to provide some of the data it needs."
    echo
    echo "Kernel messages are stored in a data structure called a ring buffer."
    echo "The buffer is fixed in size, with new data overwriting the oldest data."
    echo "When data we need has already been overwritten, that data is lost to us."
    echo
    echo "Your ring buffer has already wrapped.  Please reboot your system before"
    echo "attempting to re-run this script, to ensure that the buffer contains"
    echo "any data we need."
    echo
    exit 1
  else
    echo "dmesg ring buffer: ok"
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
fnSUDO()
{
  # If we're not already root, set "${SUDO}" so that commands that need root privs will run under sudo
  SUDO=$(type -path sudo)
  if [[ "${EUID}" -ne 0 ]] && [[ "${SUDO}" = "" ]]
  then
    echo
    echo "${0} has not been run as root and sudo is not available, exiting." >&2
    exit 1
  else
    echo "running as user:   $(whoami)"
    if [[ "${EUID}" -ne 0 ]]
    then
      if [[ -n "${SUDO}" ]]
      then
        echo "sudo is available: ok"
      fi
    fi
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnBANNER
fnCHECK_VIRT()
{
  if [[ "$(systemd-detect-virt)" = "none" ]]
  then
    echo "virtual machine:   ok"
  else
    echo
    fnBANNER " RUNNING WITHIN A VIRTUAL MACHINE IS NOT SUPPORTED"
    echo "This script does not support running inside a virtual machine."
    echo "Please exit the VM and run the script again."
    echo
    exit 1
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnBANNER
fnCHECK_CHROOT()
{
  if [[ "$(${SUDO} systemd-detect-virt --chroot 2>/dev/null)" ]]
  then
    echo
    fnBANNER " RUNNING WITHIN A CHROOT'D ENVIRONMENT IS NOT SUPPORTED"
    echo "This script does not support running in a chroot'd environment."
    echo "Please exit the chroot'd environment and run the script again."
    echo
    exit 1
  else
    echo "chroot check:      ok"
  fi
  echo
}

#---------------
# Called by fnCONFIRM_PREREQS
fnDECODE_REV()
{
  local ENCODED
  local PCB_REVISION
  local MODEL_NAME
  local PROCESSOR
  local MANUFACTURER
  local MEMORY_SIZE
  local ENCODED_FLAG
  local WARRANTY_VOID_OLD
  local WARRANTY_VOID_NEW

  ## Old-style revision codes
  ## The first set of Raspberry Pi models were given sequential hex revision codes from 0002 to 0015:
  ## Code 	Model 	Rev 	RAM 	Manufacturer
  ## 0002 	B 	1.0 	256MB 	Egoman
  ## 0003 	B 	1.0 	256MB 	Egoman
  ## 0004 	B 	2.0 	256MB 	Sony UK
  ## 0005 	B 	2.0 	256MB 	Qisda
  ## 0006 	B 	2.0 	256MB 	Egoman
  ## 0007 	A 	2.0 	256MB 	Egoman
  ## 0008 	A 	2.0 	256MB 	Sony UK
  ## 0009 	A 	2.0 	256MB 	Qisda
  ## 000d 	B 	2.0 	512MB 	Egoman
  ## 000e 	B 	2.0 	512MB 	Sony UK
  ## 000f 	B 	2.0 	512MB 	Egoman
  ## 0010 	B+ 	1.2 	512MB 	Sony UK
  ## 0011 	CM1 	1.0 	512MB 	Sony UK
  ## 0012 	A+ 	1.1 	256MB 	Sony UK
  ## 0013 	B+ 	1.2 	512MB 	Embest
  ## 0014 	CM1 	1.0 	512MB 	Embest
  ## 0015 	A+ 	1.1 	256MB/512MB 	Embest

  ## New-style revision codes in use:
  ## Code 	Model 	Rev 	RAM 	Manufacturer
  ## 900021 	A+ 	1.1 	512MB 	Sony UK
  ## 900032 	B+ 	1.2 	512MB 	Sony UK
  ## 900092 	Zero 	1.2 	512MB 	Sony UK
  ## 900093 	Zero 	1.3 	512MB 	Sony UK
  ## 9000c1 	Zero W 	1.1 	512MB 	Sony UK
  ## 9020e0 	3A+ 	1.0 	512MB 	Sony UK
  ## 920092 	Zero 	1.2 	512MB 	Embest
  ## 920093 	Zero 	1.3 	512MB 	Embest
  ## 900061 	CM 	1.1 	512MB 	Sony UK
  ## a01040 	2B 	1.0 	1GB 	Sony UK
  ## a01041 	2B 	1.1 	1GB 	Sony UK
  ## a02082 	3B 	1.2 	1GB 	Sony UK
  ## a020a0 	CM3 	1.0 	1GB 	Sony UK
  ## a020d3 	3B+ 	1.3 	1GB 	Sony UK
  ## a02042 	2B (with BCM2837) 	1.2 	1GB 	Sony UK
  ## a21041 	2B 	1.1 	1GB 	Embest
  ## a22042 	2B (with BCM2837) 	1.2 	1GB 	Embest
  ## a22082 	3B 	1.2 	1GB 	Embest
  ## a220a0 	CM3 	1.0 	1GB 	Embest
  ## a32082 	3B 	1.2 	1GB 	Sony Japan
  ## a52082 	3B 	1.2 	1GB 	Stadium
  ## a22083 	3B 	1.3 	1GB 	Embest
  ## a02100 	CM3+ 	1.0 	1GB 	Sony UK
  ## a03111 	4B 	1.1 	1GB 	Sony UK
  ## b03111 	4B 	1.1 	2GB 	Sony UK
  ## b03112 	4B 	1.2 	2GB 	Sony UK
  ## c03111 	4B 	1.1 	4GB 	Sony UK
  ## c03112 	4B 	1.2 	4GB 	Sony UK
  ## d03114 	4B 	1.4 	8GB 	Sony UK
  ## ??????     P400    ???     ???     ???????  <- THE NEW P400???

  ## The following revision-decoding logic was shamelessly borrowed from:
  ## https://raspberrypi.stackexchange.com/questions/100076/what-revisions-does-cat-proc-cpuinfo-return-on-the-new-pi-4-1-2-4gb
  ## I've made only some coding style changes to match the rest of this script.
  MY_REVISION=$(grep "Revision" < /proc/cpuinfo 2>/dev/null | awk '{print $3}')
  ENCODED=$((0x${MY_REVISION} >> 23 & 1))
  if [[ ${ENCODED} = 1 ]]
  then
    PCB_REVISION=("v1.0" "v1.1" "v1.2" "v1.3" "v1.4" "5" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15")
    MODEL_NAME=("A" "B" "A+" "B+" "Pi2B" "Alpha" "CM1" "unknown" "3B" "Zero" "CM3" "unknown" "Zero W" "3B+" "3A+" "internal use only" "CM3+" "4B" "18 ?" "19 ?" "20 ?")
    PROCESSOR=("BCM2835" "BCM2836" "BCM2837" "BCM2711" "4" "5" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15")
    MANUFACTURER=("Sony UK" "Egoman" "Embest" "Sony Japan" "Embest" "Stadium" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15")
    MEMORY_SIZE=("256 MB" "512 MB" "1024 MB" "2048 MB" "4096 MB" "8192 MB" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15")
    ENCODED_FLAG=("" "revision is a bit field")
    WARRANTY_VOID_OLD=("" "warranty void - Pre Pi2")
    WARRANTY_VOID_NEW=("" "warranty void - Post Pi2")

    # Save these for later, should we need to make decisions based on model, ram, etc.
    MY_PCB_REVISION=${PCB_REVISION[$((0x${MY_REVISION}&0xf))]}
    MY_MODEL_NAME=${MODEL_NAME[$((0x${MY_REVISION}>>4&0xff))]}
    MY_PROCESSOR=${PROCESSOR[$((0x${MY_REVISION}>>12&0xf))]}
    MY_MANUFACTURER=${MANUFACTURER[$((0x${MY_REVISION}>>16&0xf))]}
    MY_MEMORY_SIZE=${MEMORY_SIZE[$((0x${MY_REVISION}>>20&7))]}
    MY_ENCODED_FLAG=${ENCODED_FLAG[$((0x${MY_REVISION}>>23&1))]}
    MY_WARRANTY_VOID_OLD=${WARRANTY_VOID_OLD[$((0x${MY_REVISION}>>24&1))]}
    MY_WARRANTY_VOID_NEW=${WARRANTY_VOID_NEW[$((0x${MY_REVISION}>>25&1))]}
  fi
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
fnPRINT_DECODED_REV()
{
  local WARRANTY_VOID

  fnBANNER " DECODED SYSTEM REVISION NUMBER"
  echo "Revision      : ${MY_REVISION}"
  echo "PCB Revision  : ${MY_PCB_REVISION}"
  echo "Model Name    : ${MY_MODEL_NAME}"
  echo "Processor     : ${MY_PROCESSOR}"
  echo "Manufacturer  : ${MY_MANUFACTURER}"
  echo "Memory Size   : ${MY_MEMORY_SIZE}"
  echo "Encoded Flag  : ${MY_ENCODED_FLAG}"
  if [[ -n "${MY_WARRANTY_VOID_OLD}" ]] || [[ -n "${MY_WARRANTY_VOID_NEW}" ]]
  then
    WARRANTY_VOID="'warranty void' bit is set"
  else
    WARRANTY_VOID="no"
  fi
  echo "Warranty Void : ${WARRANTY_VOID}"
  echo

  # Pi 4B:
  # Revision [abc]03111 is original board with USB-C power design flaw.
  # Revision [abc]03112 is v1.2 board with fix.
  # (First char, a, b, or c, refers to 1GB, 2GB, or 4GB memory.)
  # Revision d03114 is the new v1.4 board for the Pi 4B 8GB
  # (First char, d, refers to 8GB memory.)
  if [[ "$(echo "${MY_REVISION}" | cut -c2-)" = "03111" ]]
  then
    echo "This 4B contains a USB-C power design flaw."
    echo "\"Smart\" USB-C cables will not power this Pi."
    echo
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
# Calls fnBANNER
fnCHK_PACKAGES()
{
  local PKG_MISSING
  local REQUIRED
  local REQ_HIT
  local REQ_MAX
  local PIGPIO_PKG
  local DOCKER_PKG
  local SUPPLEMENTAL
  local SUP_HIT
  local SUP_MAX

  PKG_MISSING=0
  if type -path dpkg >/dev/null 2>&1
  then
    #################################
    # First, the required packages
    REQUIRED=$(dpkg -l 2>/dev/null | awk '{ print $2 }' | grep -i "^alsa-utils$\|^bc$\|^bluez$\|^coreutils$\|^cron$\|^i2c-tools$\|^initramfs-tools$\|^iproute2$\|^libraspberrypi-bin$\|^lshw$\|^net-tools$\|^procps$\|^rpi-eeprom$\|^sed$\|^util-linux$\|^usbutils$\|^v4l-utils$\|^wireless-tools$")
    REQ_HIT=0
    REQ_MAX=0
    for PACKAGE in alsa-utils bc bluez coreutils cron i2c-tools initramfs-tools iproute2 libraspberrypi-bin lshw net-tools procps rpi-eeprom usbutils sed util-linux v4l-utils wireless-tools
    do
      # If the Pi is not a 4B, skip checking for the rpi-eeprom package
      if [[ "${MY_MODEL_NAME}" != "4B" ]] && [[ "${PACKAGE}" = "rpi-eeprom" ]]
      then
        continue
      fi
      # Otherwise, for all packages, on all models...
      # If the package is installed...
      if [[ "$(echo "${REQUIRED}" | grep "${PACKAGE}")" != "" ]]
      then
        (( REQ_HIT++ ))
      else
        # Otherwise, tell the user to install it.
        fnBANNER "Required package \"${PACKAGE}\" is not installed." | grep -v "^$"
        echo "Install with:"
        echo "  sudo apt install -y ${PACKAGE}"
        PKG_MISSING=1
        echo
      fi
      (( REQ_MAX++ ))
    done
    if [[ ${PKG_MISSING} -ne 0 ]]
    then
      fnBANNER "Once any missing packages are installed, re-run this script."
      echo
      exit
    else
      echo "${REQ_HIT} out of ${REQ_MAX} required packages are installed."
      echo "All core inspections will be performed."
      echo

      ######################################
      # Now, the supplemental packages.
      # If installed, great.  If not installed, don't trouble the user to add them.

      # Some of the supplemental package names have changed, between Stretch and Buster.  The next few lines
      # accomodate these different package names.
      # The package containing daemon "pigpiod" is called "pigpiod" on Buster, but called "pigpio" on Stretch.
      # The package containing "docker" is called "docker-ce-cli" on Buster, but called "docker.io" on Stretch.
      if [[ "${VERSION_ID}" -eq 9 ]]
      then
        # Package names on Stretch
        PIGPIO_PKG=pigpio
        DOCKER_PKG=docker.io
      else
        # Package names on Buster
        PIGPIO_PKG=pigpiod
        DOCKER_PKG=docker-ce-cli
      fi

      # The packages conditionally named above, appear as variables here...
      SUPPLEMENTAL=$(dpkg -l 2>/dev/null | awk '{ print $2 }' | grep -i "^apparmor$\|^at$\|^auditd$\|^chkrootkit$\|^clamav$\|^cups-client$\|^dc$\|^${DOCKER_PKG}$\|^ethtool$\|^hdparm$\|^lirc$\|^lm-sensors$\|^lvm2$\|^lynis$\|^m4$\|^mdadm$\|^nfs-kernel-server$\|^nmap$\|^perl-base$\|^${PIGPIO_PKG}$\|^python3-gpiozero$\|^quota$\|^rkhunter$\|^rng-tools$\|^rpcbind$\|^rtl-sdr$\|^samba$\|^smartmontools$\|^snort$\|^sysbench$\|^sysstat$\|^systemd-container$\|^systemd-coredump$\|^tripwire$\|^ufw$\|^unhide$\|^watchdog$\|^wiringpi$\|^x11-xserver-utils$")
      SUP_HIT=0
      SUP_MAX=0
      # They also appear as variables here...
      for PACKAGE in apparmor at auditd chkrootkit clamav cups-client dc ${DOCKER_PKG} ethtool hdparm lirc lm-sensors lvm2 lynis m4 mdadm nfs-kernel-server nmap perl-base ${PIGPIO_PKG} python3-gpiozero quota rkhunter rng-tools rpcbind rtl-sdr samba smartmontools snort sysbench sysstat systemd-container systemd-coredump tripwire ufw unhide watchdog wiringpi x11-xserver-utils
      do
        # If wiringpi is installed, it needs to be v2.52 on the Pi 4B - 1/2/4GB models only..
        # See - http://wiringpi.com/wiringpi-updated-to-2-52-for-the-raspberry-pi-4b/
        # This script will not support WiringPi, of any version, on a Pi 4B 8GB model.
        if [[ "${PACKAGE}" = "wiringpi" ]]
        then
          WIRINGPI_VERS=$(gpio -v 2>/dev/null | head -1 | awk '{ print $NF }')
          if [[ "${MY_REVISION}" != "d03114" ]] && [[ "${WIRINGPI_VERS}" = "2.52" ]]
          then
            (( SUP_HIT++ ))
            (( SUP_MAX++ ))
            continue
          fi
          # If not a 4B, then wiringpi v2.50 from the repositories will do
          if [[ "${MY_MODEL_NAME}" != "4B" ]]
          then
            (( SUP_HIT++ ))
          fi
          (( SUP_MAX++ ))
        else
          # Otherwise, for all other packages, on all models...
          # If the package is installed...
          if [[ "$(echo "${SUPPLEMENTAL}" | grep "${PACKAGE}")" != "" ]]
          then
            (( SUP_HIT++ ))
#KPC
#         else
#           echo "package ${PACKAGE} not found"
          fi
          (( SUP_MAX++ ))
        fi
      done
      echo "${SUP_HIT} out of ${SUP_MAX} supplemental packages are installed."
      if [[ "${SUP_HIT}" -gt 0 ]]
      then
        echo "Some supplemental inspections can be performed."
      else
        echo "No supplemental inspections can be performed."
      fi
      echo
    fi
  else
    echo "Missing utility dpkg, unable to verify package dependencies" >&2
    exit 1
  fi
}

#---------------
# Called by fnCONFIRM_PREREQS
fnLSHW_BUSINFO()
{
  echo -n "One moment, please... "
  ${SUDO} lshw -businfo >/tmp/.lshw_businfo.${PPID} 2>/dev/null
  # The tmpfile negates need to run the above slow command multiple times.
  # we'll grab the next few variables now, for use in later routines.
  LSHW_INPUT=$(grep "input" /tmp/.lshw_businfo.${PPID} 2>/dev/null | head -1)
  LSHW_STORAGE=$(grep "storage" /tmp/.lshw_businfo.${PPID} 2>/dev/null | head -1)
  LSHW_GENERIC=$(grep "generic" /tmp/.lshw_businfo.${PPID} 2>/dev/null | head -1)
  LSHW_MULTIMEDIA=$(grep "multimedia" /tmp/.lshw_businfo.${PPID} 2>/dev/null | head -1)
  LSHW_COMMUNICATION=$(grep "communication" /tmp/.lshw_businfo.${PPID} 2>/dev/null | head -1)
  echo "Ready."
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
fnSYSTEM_ID()
{
  fnBANNER " SYSTEM IDENTIFICATION"
  echo "Hostname: $(hostname)"
  echo "Serial #: $(grep ^Serial < /proc/cpuinfo 2>/dev/null | awk '{ print $NF }')"
  echo
}

#---------------
# Called by fnOS
fnMODPROBE_CONFIGS()
{
  MODPROBE_CONFIGS=0
  if [[ "$(lsmod | grep configs)" = "" ]]
  then
    ${SUDO} modprobe configs
    MODPROBE_CONFIGS=1
  fi
}

#---------------
# Called by fnOS
fnRMMOD_CONFIGS()
{
  if [[ "$(lsmod | grep configs)" != "" ]] && [[ "${MODPROBE_CONFIGS}" -eq 1 ]]
  then
    ${SUDO} rmmod configs
    MODPROBE_CONFIGS=0
  fi
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER, fnMODPROBE_CONFIGS, fnRMMOD_CONFIGS
fnOS()
{
  local TARGET
  local AUTOLOGIN_GUI
  local AUTOLOGIN_TTY

  fnBANNER " OPERATING SYSTEM"
  echo "${PRETTY_NAME}"
  uname -a
  echo

  if [[ "$(vcgencmd get_config arm_64bit | cut -f2 -d"=")" = "1" ]]
  then
    echo "KERNEL IS........... 64-BIT"
  else
    echo "KERNEL IS........... 32-BIT"
  fi

  if [[ -c /dev/kvm ]]
  then
    echo "KVM SUPPORT......... enabled"
  else
    echo "KVM SUPPORT......... disabled"
  fi

  fnMODPROBE_CONFIGS

  if [[ "$(${SUDO} gunzip -c /proc/config.gz | grep "CONFIG_SECURITY_SELINUX=[ym]")" != "" ]]
  then
    echo "SELINUX............. enabled"
    HAS_SELINUX="yes"
  else
    echo "SELINUX............. not present in this kernel"
    HAS_SELINUX="no"
  fi
  if [[ "$(${SUDO} gunzip -c /proc/config.gz | grep "CONFIG_SECURITY_APPARMOR=[ym]")" != "" ]]
  then
    echo "APPARMOR............ enabled"
    HAS_APPARMOR="yes"
  else
    echo "APPARMOR............ not present in this kernel"
    HAS_APPARMOR="no"
  fi
  if [[ "$(${SUDO} gunzip -c /proc/config.gz | grep "CONFIG_AUDIT=[ym]")" != "" ]]
  then
    echo "AUDITD SUPPORT...... enabled"
    HAS_AUDITD="yes"
  else
    echo "AUDITD SUPPORT...... not present in this kernel"
    HAS_AUDITD="no"
  fi
  echo

  fnRMMOD_CONFIGS

  echo -n "DEFAULT BOOT TARGET. "
  TARGET="$(stat /lib/systemd/system/default.target | grep "File:" | awk '{ print $NF }')"
  systemctl list-units --type=target | grep "${TARGET}" | awk '{ print $5" "$6" "$7" "$8" "$9 }'

  if [[ -f /etc/lightdm/lightdm.conf ]]
  then
    echo -n "GUI AUTOLOGIN....... "
    AUTOLOGIN_GUI="$(grep "^autologin-user=" /etc/lightdm/lightdm.conf | cut -f2 -d"=")"
    if [[ -n "${AUTOLOGIN_GUI}" ]]
    then
      echo "${AUTOLOGIN_GUI}"
    else
      echo "none"
    fi
  fi

  echo -n "TTY AUTOLOGIN....... "
  AUTOLOGIN_TTY="$(grep "^ExecStart=" /lib/systemd/system/getty@.service | grep "autologin" | awk '{ print $3 }')"
  if [[ -n "${AUTOLOGIN_TTY}" ]]
  then
    echo "${AUTOLOGIN_TTY}"
  else
    echo "none"
  fi
  echo

  echo "BASH VERSION........ ${BASH_VERSION}"
  echo

  echo -n "UPTIME.............. "
  uptime -p
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
fnMAC()
{
  local MACS

  fnBANNER " MAC-ADDRESS(ES)"
  ifconfig | grep '[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:' | awk '{print $2}' | tr "a-f" "A-F" | sort
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
fnMODEL()
{
  fnBANNER " MODEL AND FIRMWARE VERSION"
  strings /sys/firmware/devicetree/base/model
  echo
  cat /etc/rpi-issue
  echo
  vcgencmd version
  echo
  fnBANNER " VIDEO CORE VERSION AND LOG STATUS"
  vcgencmd vcos version
  echo
  vcgencmd vcos log status
  echo
  fnBANNER " VIDEO CORE OUT-OF-MEMORY EVENTS"
  vcgencmd mem_oom
  echo
  fnBANNER " VIDEO CORE RELOCATABLE MEMORY STATS"
  vcgencmd mem_reloc_stats
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
fnDIAGRAM()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path pinout >/dev/null 2>&1
  then
    fnBANNER " SYSTEM DIAGRAM (***)"
    pinout -m
    echo
  fi
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
fnCPU()
{
  fnBANNER " CPU INFORMATION"
  lscpu
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER, fnSUB_BANNER
fnSENSORS()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path sensors >/dev/null 2>&1
  then
    fnBANNER " LM-SENSORS (***)"
    sensors
  fi
  if type -path sensors-detect >/dev/null 2>&1
  then
    fnSUB_BANNER " Searching for sensors..."
    ${SUDO} sensors-detect --auto
    echo
  fi
  echo " ----------------------------------------------------"
  systemctl status lm-sensors.service
  echo
}

#---------------
# Called by fnGROUP_HARDWARE
# Calls fnBANNER
fnHOW_BOOT()
{
  local MY_OTP
  local BOOT_TO_USB

  # Boot-from-USB mass storage will be handled differently on the Pi 4B,
  # versus older models.
  if [[ "${MY_MODEL_NAME}" = "4B" ]]
  then
    # The Pi 4 uses an EEPROM to control it's boot source.
    fnBANNER " PI MODEL 4B EEPROM VERSION"
    vcgencmd bootloader_version
    echo
    if type -path rpi-eeprom-update >/dev/null 2>&1
    then
      # This command will indicate that an update is required, if the
      # timestamp of the most recent file in the firmware directory
      # (normally /lib/firmware/raspberrypi/bootloader/critical)
      # is newer than that reported by the current bootloader.
      fnBANNER " PI MODEL 4B EEPROM UPDATE STATUS"
      ${SUDO} rpi-eeprom-update
      echo
    else
      echo "Missing utility rpi-eeprom-update, skipping eeprom update check" >&2
    fi

    fnBANNER " PI MODEL 4B EEPROM CONFIG"
    echo "The meaning of each of these is documented here:"
    echo "https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2711_bootloader_config.md"
    echo
    vcgencmd bootloader_config
  else
    # Some older Pi models use OTP (One Time Programable) memory to control
    # whether the Pi can boot from USB mass storage.  Here, we check the
    # model, and then perform the appropriate examination.  OTP-managed
    # USB mass storage boot is available on Pi 2B v1.2, 3A+, 3B, and 3B+
    # models only.  Any other model will skip this test.  The Pi 3B+
    # comes from the factory with boot from USB mass storage enabled.
    # If a Model 2B, make sure it's a v1.2 unit.
    MY_OTP=${MY_MODEL_NAME}
    if [[ "${MY_MODEL_NAME}" = "Pi2B" ]] && [[ "${MY_PROCESSOR}" = "BCM2837" ]]
    then
      MY_OTP="Pi2Bv1.2"
    fi
    case ${MY_OTP} in
      Pi2Bv1.2|3A+|3B|3B+)
        fnBANNER " OTP BOOT-FROM-USB STATUS"
        BOOT_TO_USB=$(vcgencmd otp_dump | grep "17:")
        if [[ "${BOOT_TO_USB}" = "17:3020000a" ]]
        then
          echo "Boot From USB: Enabled"
        else
          echo "Boot From USB: Available, but not enabled"
        fi
        ;;
      * )
        echo "Boot From USB: Feature not available on this model"
        ;;
    esac
    echo
  fi
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
fnDTOVERLAYS()
{
  fnBANNER " ACTIVE DEVICE TREE OVERLAYS"
  ${SUDO} vcdbg log msg 2>&1 | grep "Loaded overlay" | cut -f2- -d":"
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
fnDTPARAMS()
{
  fnBANNER " ACTIVE DEVICE TREE PARAMS"
  ${SUDO} vcdbg log msg 2>&1 | grep "dtparam:" | cut -f2- -d":"
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
fnSYSCTL()
{
  fnBANNER " SYSCTL KERNEL VARIABLES"
  cat /etc/sysctl.conf /etc/sysctl.d/*.conf | grep -v "^$\|^#" | sort
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
fnLEDS()
{
  local TRIGGER

  # This section needs study for Pi 4 ethernet LEDs...
  # dtparam=eth_led0=4
  # dtparam=eth_led1=4
  #
  # perhaps use "sudo vcdbg log msg" and grep for:
  # dtparam: eth_led0=
  # dtparam: eth_led1=
  # (maybe even "dtparam: act_led_trigger=heartbeat" for ACT LED, below, too.)
  #
  # eth_led0 is green
  # eth_led1 is amber
  #
  # The comments are also hard to decipher (e.g. what's the difference between 0, 2, and 7?):
  # 0=Speed/Activity (default) 1=Speed
  # 2=Flash activity           3=FDX
  # 4=Off                      5=On
  # 6=Alt                      7=Speed/Flash
  # 8=Link                     9=Activity
  #
  # My understanding is:
  #
  # Speed means on for a fast link (probably 1Gb/s), otherwise off.
  #
  # Activity inverts the current state for a short period for every packet,
  # so more traffic means more flicker.
  #
  # Flash activity is like Activity but without the proportionality - the pulses
  # (which could be on or off depending on the other part of the mode) are a
  # fixed width and the gaps are of (the same) minimum width, such that you
  # see a clear flash pattern if there is activity and a steady state if not.
  #
  # It looks like 2 is mislabelled and should just say Flash activity.
  #
  fnBANNER " LED TRIGGERS"
  TRIGGER=""
  if [[ -f /sys/class/leds/led0/trigger ]]
  then
    echo -n "LED0: "
    sed 's/ /\n/g' < /sys/class/leds/led0/trigger | while read -r TRIGGER
    do
      echo "${TRIGGER}" | grep "\["
    done
  fi
  if [[ -f /sys/class/leds/led1/trigger ]]
  then
    echo -n "LED1: "
    sed 's/ /\n/g' < /sys/class/leds/led1/trigger | while read -r TRIGGER
    do
      echo "${TRIGGER}" | grep "\["
    done
  fi
  if [[ -f /sys/class/leds/mmc0::/trigger ]]
  then
    echo -n "MMC0: "
    sed 's/ /\n/g' < /sys/class/leds/mmc0::/trigger | while read -r TRIGGER
    do
      echo "${TRIGGER}" | grep "\["
    done
  fi
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
fnCMDLINE()
{
  fnBANNER " CMDLINE.TXT"
  cat /boot/cmdline.txt 2>/dev/null
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
fnCONFIGTXT()
{
  fnBANNER " CONFIG.TXT SETTINGS"
  grep -v "^$\|^#" < /boot/config.txt 2>/dev/null
  echo
}

#---------------
# Called by fnGROUP_MEMORY
# Calls fnBANNER
fnMEMSPLIT()
{
  local ARM
  local GPU

  fnBANNER " MEMORY SPLIT"
  # There is a flaw in "vcgencmd get_mem arm" on Pi 4B models with more than 1GB of memory.
  # On those models, the command only considers the first GB of memory.
  # The technique used here instead, is accurate on all Pi models regardless of memory.
  ARM=$(($(dmesg | grep "Memory:" | grep "available" | cut -f2 -d"/" | cut -f1 -d"K") / 1024 ))
  ARM=$(printf "%4d" ${ARM})
  echo "ARM: ${ARM} MB"
  GPU="$(vcgencmd get_mem gpu | cut -f2 -d"=" | sed 's/M$//')"
  GPU=$(printf "%4d" "${GPU}")
  echo "GPU: ${GPU} MB"
  echo
  echo "Note: GPU hardware-accelerated codecs will be disabled if \"gpu_mem=16\"."
  echo "At least \"gpu_mem=96\" is required for HW codecs to run correctly."
  echo "At least \"gpu_mem=128\" is required for camera operation."
  echo
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
fnDISPDRV()
{
  fnBANNER " ACTIVE DISPLAY DRIVER"
  # If two particular modules are not running, it's the Broadcom driver.
  # If the modules are loaded, the "fake" OpenGL driver shows "firmwarekms" in dmesg.
  # If the modules are loaded, the "full" OpenGL driver does not show "firmwarekms" in dmesg.
  # An example of why we needed to check for ring buffer wrap earlier,
  # We need to remember which driver is used - we'll need this info later.
  if [[ "$(lsmod | awk '{ print $1 }' | grep ^vc4)" = "" ]] && [[ "$(lsmod | awk '{ print $1 }' | grep ^drm)" = "" ]]
  then
    DISP_DRIVER="broadcom"
    echo "Broadcom Display Driver"
  else
    if [[ "$(dmesg | grep firmwarekms)" != "" ]]
    then
      DISP_DRIVER="fake"
      echo "\"Fake\" OpenGL Display Driver"
    else
      DISP_DRIVER="full"
      echo "\"Full\" OpenGL Display Driver"
    fi
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
fnPROCSPEED()
{
  local FREQ
  local MHZ

  fnBANNER " PROCESSOR SPEEDS"
  FREQ=$(vcgencmd measure_clock arm | cut -f2 -d"=")
  MHZ=$((FREQ / 1000000))
  MHZ=$(printf "%4d" "${MHZ}")
  echo " CPU: ${MHZ} MHz"
  FREQ=$(vcgencmd measure_clock core | cut -f2 -d"=")
  MHZ=$((FREQ / 1000000))
  MHZ=$(printf "%4d" "${MHZ}")
  echo "CORE: ${MHZ} MHz"
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
fnOVERCLOCK()
{
  local CLOCK_STUFF

  # For details see:
  # https://www.raspberrypi.org/documentation/configuration/config-txt/overclocking.md

  CLOCK_STUFF=$(grep -v "^$\|^#" /boot/config.txt | grep -i "^arm_freq=\|^gpu_freq=\|^core_freq=\|^h264_freq=\|^isp_freq=\|^v3d_freq=\|^hevc_freq=\|^sdram_freq=\|^over_voltage=\|^over_voltage_sdram=\|^over_voltage_sdram_c=\|^over_voltage_sdram_i=\|^over_voltage_sdram_p=\|^force_turbo=\|^initial_turbo=\|^arm_freq_min=\|^core_freq_min=\|^gpu_freq_min=\|^h264_freq_min=\|^isp_freq_min=\|^v3d_freq_min=\|^hevc_freq_min=\|^sdram_freq_min=\|^over_voltage_min=\|^temp_limit=\|^temp_soft_limit=\|^hdmi_enable_4kp60=\|^enable_tvout=")

  if [[ -n "${CLOCK_STUFF}" ]]
  then
    fnBANNER " CLOCKSPEED / OVERCLOCKING OPTIONS FOUND IN CONFIG.TXT"
    echo "${CLOCK_STUFF}" | sort
    echo
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
fnRING_OSCILLATOR()
{
  local ALL
  local C
  local F

  fnBANNER " RING OSCILLATOR STATS"
  if type -path dc >/dev/null 2>&1
  then
    # SUPPLEMENTAL CONVERSION to Fahrenheit
    ALL="$(vcgencmd read_ring_osc)"
    C="$(vcgencmd read_ring_osc | cut -f4 -d"(" | cut -f1 -d"'")"
    F="$(echo "2 k 9 5 / ${C} * 32 + p" | dc)"
    echo "${ALL} ($(printf "%3.1f" "${F}")${DEG_SYMBOL}F) (***)"
  else
    vcgencmd read_ring_osc
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
fnCLOCKFREQ()
{
  local CLOCK

  fnBANNER " CLOCK FREQUENCIES"
  if [[ "${MY_MODEL_NAME}" = "4B" ]]
  then
    echo "Clocks available across all Pi models..."
  fi
  for CLOCK in arm core h264 isp v3d uart pwm emmc pixel vec hdmi dpi
  do
    echo "${CLOCK}: $(vcgencmd measure_clock ${CLOCK})" | awk '{ printf("%- 10s %- 28s\n", $1, $2);}' 2>&1
  done
  if [[ "${MY_MODEL_NAME}" = "4B" ]]
  then
    echo
    echo "Additional Pi 4B-specific clocks..."
    for CLOCK in altscb cam0 cam1 ckl108 clk27 clk54 debug0 debug1 dft dsi0 dsi0esc dsi1 dsi1esc emmc2 genet125 genet250 gisb gpclk0 gpclk1 hevc m2mc otp pcm plla pllb pllc plld pllh pulse smi tectl testmux tsens usb wdog xpt
    do
      echo "${CLOCK}: $(vcgencmd measure_clock ${CLOCK})" | awk '{ printf("%- 10s %- 28s\n", $1, $2);}' 2>&1
    done
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
fnVOLTS()
{
  local VOLTS

  fnBANNER " VOLTAGES"
  if [[ "${MY_MODEL_NAME}" = "4B" ]]
  then
    echo "Voltages available across all Pi models..."
  fi
  for VOLTS in core sdram_c sdram_i sdram_p
  do
    echo "${VOLTS}: $(vcgencmd measure_volts ${VOLTS})" | awk '{ printf("%- 10s %- 40s\n", $1, $2);}' 2>&1
  done
  if [[ "${MY_MODEL_NAME}" = "4B" ]]
  then
    echo
    echo "Additional Pi 4B-specific voltages..."
    vcgencmd measure_volts 2711 | sed 's/ /\n/g' | while read -r VOLTS
    do
      echo -e "2711: ${VOLTS}" | awk '{ printf("%- 10s %- 40s\n", $1, $2);}' 2>&1
    done
    for VOLTS in ain1 usb_pd uncached
    do
      echo "${VOLTS}: $(vcgencmd measure_volts ${VOLTS})" | awk '{ printf("%- 10s %- 40s\n", $1, $2);}' 2>&1
    done
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
fnTEMPS()
{
  local GPU_TEMP
  local ARM_TEMP
  local PMIC_TEMP
  local C
  local F

  fnBANNER " TEMPERATURE"
  # Pointless venting - I wish bash could do floating point
  # math directly in the shell like ksh can, without needing
  # bc, dc, expr, awk, or other external commands.  Argh!
  if [[ "${MY_MODEL_NAME}" = "4B" ]]
  then
    echo "Temperatures available across all Pi models..."
  fi
  GPU_TEMP=$(vcgencmd measure_temp)
  C=$(echo "${GPU_TEMP}" | cut -f2 -d"=" | cut -f1 -d"'")
  if type -path dc >/dev/null 2>&1
  then
    # SUPPLEMENTAL CONVERSION to Fahrenheit
    F=$(echo "2 k 9 5 / ${C} * 32 + p" | dc)
    echo " GPU Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C ($(printf "%3.2f" "${F}")${DEG_SYMBOL}F) (***)"
  else
    # Otherwise, show Centigrade/Celcius only
    echo " GPU Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C"
  fi
  ARM_TEMP=$(cat /sys/class/thermal/thermal_zone0/temp 2>/dev/null)
  C=$(echo "scale=2;${ARM_TEMP}/1000" | bc)
  if type -path dc >/dev/null 2>&1
  then
    # SUPPLEMENTAL CONVERSION to Fahrenheit
    F=$(echo "2 k 9 5 / ${C} * 32 + p" | dc)
    echo " ARM Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C ($(printf "%3.2f" "${F}")${DEG_SYMBOL}F) (***)"
  else
    # Otherwise, show Centigrade/Celcius only
    echo " ARM Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C"
  fi

  if [[ "${MY_MODEL_NAME}" = "4B" ]]
  then
    echo
    echo "Additional Pi 4B-specific PMIC temperature..."
    PMIC_TEMP=$(vcgencmd measure_temp pmic)
    C=$(echo "${PMIC_TEMP}" | cut -f2 -d"=" | cut -f1 -d"'")
    if type -path dc >/dev/null 2>&1
    then
      # SUPPLEMENTAL CONVERSION to Fahrenheit
      F=$(echo "2 k 9 5 / ${C} * 32 + p" | dc)
      echo "PMIC Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C ($(printf "%3.2f" "${F}")${DEG_SYMBOL}F) (***)"
    else
      # Otherwise, show Centigrade/Celcius only
      echo "PMIC Temp: $(printf "%2.2f" "${C}")${DEG_SYMBOL}C"
    fi
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
fnGOV()
{
  local GOV
  local FORCE

  fnBANNER " SCALING GOVERNOR"
  GOV=$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null)
  FORCE=$(grep "^force_turbo=" /boot/config.txt 2>/dev/null | cut -f2 -d"=")

  # The possible governor settings are:
  #   performance  - always use max cpu freq
  #   powersave    - always use min cpu freq
  #   ondemand     - change cpu freq depending on cpu load (On rasbian, it just switches min and max)
  #   conservative - smoothly change cpu freq depending on cpu load
  #   uesrspace    - allow user space daemon to control cpufreq
  #   schedutil    - wiser about freq. selection than the other governors, but not quite there yet
  # All but "performance" are overridden by "force_turbo=1" in config.txt.
  # Both of those mean the same thing - run at max speed, all the time..

  echo "${GOV}"
  if [[ "${GOV}" != "performance" ]] && [[ "${FORCE}" = "1" ]]
  then
    echo "(...but overridden by \"force_turbo=1\" found in config.txt)"
  fi
  echo
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
fnTHROTTLES()
{
  local UNDERVOLTED
  local CAPPED
  local THROTTLED
  local SOFT_TEMPLIMIT
  local HAS_UNDERVOLTED
  local HAS_CAPPED
  local HAS_THROTTLED
  local HAS_SOFT_TEMPLIMIT
  local GOOD
  local BAD
  local STATUS

  fnBANNER " DECODED PROCESSOR THROTTLING STATUS"
  # These are what cause the overtemp (thermometer) icon,
  # the undervolt (lightening bolt) icon, etc., to be
  # displayed on a screen, when there's a problem.
  #
  # "vcgencmd get_throttled"
  # Bit Meaning
  # ===============
  #  0 Undervoltage currently detected
  #  1 Arm frequency currently capped
  #  2 Currently throttled
  #  3 Soft temperature limit currently active
  # 16 Under voltage has occured at least once since last boot
  # 17 Arm frequency cap has occured at least once since last boot
  # 18 Throttling has occurred at least once since last boot
  # 19 Soft Temperature limit has occurred at least once since last boot

  #Flag Bits
  UNDERVOLTED=0x1
  CAPPED=0x2
  THROTTLED=0x4
  SOFT_TEMPLIMIT=0x8
  HAS_UNDERVOLTED=0x10000
  HAS_CAPPED=0x20000
  HAS_THROTTLED=0x40000
  HAS_SOFT_TEMPLIMIT=0x80000

  #Output Strings
  GOOD="no"
  BAD="YES"

  #Get Status, extract hex
  STATUS=$(vcgencmd get_throttled)
  STATUS=${STATUS#*=}

  echo -n "Throttle Status: "
  ((STATUS!=0)) && echo "${STATUS}" || echo "${STATUS}"
  echo

  echo "Undervolted:"
  echo -n "    Currently: "
  (((STATUS&UNDERVOLTED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo -n "   Since Boot: "
  (((STATUS&HAS_UNDERVOLTED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo
  echo "Throttled:"
  echo -n "    Currently: "
  (((STATUS&THROTTLED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo -n "   Since Boot: "
  (((STATUS&HAS_THROTTLED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo
  echo "Frequency Capped:"
  echo -n "    Currently: "
  (((STATUS&CAPPED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo -n "   Since Boot: "
  (((STATUS&HAS_CAPPED)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo
  echo "Softlimit:"
  echo -n "    Currently: "
  (((STATUS&SOFT_TEMPLIMIT)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo -n "   Since Boot: "
  (((STATUS&HAS_SOFT_TEMPLIMIT)!=0)) && echo "${BAD}" || echo "${GOOD}"
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
fnULIMIT_CORE()
{
  local ULIMIT
  local HITS

  # SUPPLEMENTAL STUFF HERE
  fnBANNER " ULIMIT AND CORE DUMPS (***)"
  ulimit -a
  echo

  ULIMIT=$(ulimit -c)
  case ${ULIMIT} in
    "0")
      echo " Core dumps are disabled..."
      echo "ulimit = 0"
      ;;
    "unlimited")
      echo " Core dumps are enabled..."
      echo "ulimit = unlimited"
      ;;
    *)
      echo " Core dumps are enabled..."
      echo "ulimit = ${ULIMIT}"
      ;;
  esac
  echo

  HITS=$(find /etc/security/limits* -type f -exec grep core {} \; | grep -v "^#")
  if [[ -n "${HITS}" ]]
  then
    echo " Core dumps are enabled globally in /etc/security/limits*..."
    echo "${HITS}"
    echo
  fi

  HITS=$(find /etc/systemd/system.conf -type f -exec grep DefaultLimitCORE {} \; | grep -v "^#")
  if [[ -n "${HITS}" ]]
  then
    echo " Default global core dump limit in /etc/systemd/system.conf..."
    echo "${HITS}"
    echo
  fi

  if [[ -f /etc/systemd/coredump.conf ]]
  then
    echo " Contents of /etc/systemd/coredump.conf..."
    grep -v "^# " < /etc/systemd/coredump.conf 2>/dev/null | grep -v "^#$" | grep -v "^$"
    echo
  fi

  if [[ "$(journalctl -xe | grep "dumped core")" != "" ]]
  then
    echo " journalctl -xe..."
    journalctl -xe | grep "dumped core"
    echo
  fi

  if type -path coredumpctl >/dev/null 2>&1
  then
    echo " journalctl reports the following core dumps..."
    ${SUDO} coredumpctl list 2>&1
    echo
    echo " Core dumps present in /var/lib/systemd/coredump..."
    ls -l /var/lib/systemd/coredump
    echo
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
fnQUOTAS()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path repquota >/dev/null 2>&1
  then
    if [[ "$(grep "[usr\|grp]quota" /etc/fstab 2>/dev/null | grep -v "^#")" != "" ]]
    then
      fnBANNER " QUOTAS (***)"
      echo " The following filesystems are configured for quotas..."
      grep "[usr\|grp]quota" /etc/fstab 2>/dev/null | grep -v "^#"
      echo
      ${SUDO} repquota -u -g -v -a -s -t | grep -v "^#"
    fi
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
fnOVERLAYFS()
{
  local MOUNT_STATUS

  if [[ "$(grep "boot=overlay" /boot/cmdline.txt)" != "" ]]
  then
    fnBANNER " OVERLAY FILESYSTEM"
    echo "Found \"boot=overlay\" in cmdline.txt"
    echo
    echo "Fhe following initrd.img overlay files are in /boot:"
    find /boot -print | grep initrd.img
    echo
    echo "Mounted overlay filesystems:"
    df -Th -t overlay 2>&1
    echo
    echo "Checking fstab for read-only /boot filesystem:"
    grep /boot /etc/fstab | grep "ro" | grep -v "^#"
    echo
    echo "Current status of /boot filesystem:"
    MOUNT_STATUS="$(mount | grep "/boot" | cut -f2 -d"(" | cut -f1 -d",")"
    case ${MOUNT_STATUS} in
      "rw") echo "/boot is currently read-write"
        ;;
      "ro") echo "/boot is currently read-only"
        ;;
      *)    echo "unknown"
        ;;
    esac
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
fnCODECS()
{
  local CODEC
  local STATUS
  local LIC_STATUS

  fnBANNER " HARDWARE-ACCELERATED CODECS"
  # FOR THE PI 4B...
  # On the Raspberry Pi 4B, hardware decoding for MPG2 and WVC1
  # is disabled and cannot be enabled even with a license key.
  # The Pi 4B, with it's increased processing power compared to
  # earlier models, can decode these in software such as VLC.
  # MPG4, H263, MPG2, and WVC1 hardware decode options have all
  # been dropped, on the 4B.  The ARM cores on the Pi4 are more
  # than capable of decoding those formats at better that real-
  # time.  (There is no real material >1080p using those codecs.)
  #
  # FOR OLDER MODELS...
  # Hardware decoding of MPG2 and WVC1 requires license keys,
  # purchased seperately.
  CODEC=""
  STATUS=""
  for CODEC in AGIF FLAC H263 H264 MJPA MJPB MJPG MPG2 MPG4 MVC0 " PCM" THRA VORB " VP6" " VP8" WMV9 WVC1
  do
    STATUS=$(vcgencmd codec_enabled "${CODEC}" | cut -f2 -d"=")
    # These two codecs...
    if [[ "${CODEC}" = "MPG2" ]] || [[ "${CODEC}" = "WVC1" ]]
    then
      # ...on models other than the 4B...
      if [[ "${MY_MODEL_NAME}" != "4B" ]]
      then
        # ...if enabled...
        if [[ "${STATUS}" = "enabled" ]]
        then
          #... are marked as licensed.
          LIC_STATUS="(licensed)"
        else
          # If not enabled on these models, a license is required to enable.
          LIC_STATUS="(license required to enable)"
        fi
        # We then show their status (including whether licensed).
        echo "${CODEC}: ${STATUS} ${LIC_STATUS}"
      else
        # For other codecs, just show their status.
        echo "${CODEC}: ${STATUS}"
      fi
    else
      # Otherwise, show each codec's status, without concern for license.
      echo "${CODEC}: ${STATUS}"
    fi
  done
  echo
  echo "Note 1: VP6, VP8, and MJPG are not handled by the hardware video decoder"
  echo "in the Broadcom BCM2835 processor, but by the VideoCore GPU.  Enable these"
  echo "by running:  sudo raspi-config -> Interfacing Options -> Camera -> Enable"
  echo "or by adding \"start_x=1\" to /boot/config.txt"
  echo
  echo "Note 2: GPU hardware-accelerated codecs will be disabled if \"gpu_mem=16\"."
  echo "At least \"gpu_mem=96\" is required for the codecs to run correctly."
  echo
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
fnV4L2CODECS()
{
  fnBANNER " V4L2-CTL CODECS"
  v4l2-ctl -d 10 --list-formats-out
  if [[ "$(v4l2-ctl -d 10 --list-formats-out | grep "Pixel")" = "" ]]
  then
    echo
  fi
  if [[ "${MY_MODEL_NAME}" = "4B" ]]
  then
    echo "Note: The H.265 codec, new w/ the Pi 4B, isn't part of the videocore."
    echo "It's an entirely new block on the chip, so the VC6 knows nothing"
    echo "about it.  Therefore, vcgencmd (which talks to the VC6) also knows"
    echo "nothing about it.  The v4l2-ctl command used here, however, should"
    echo "show the H.265 codec, when enabled, on the Pi 4B."
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
fnV4LDEV()
{
  local DEV

  # The Pi itself, will have /dev/video10 (decode), /dev/video11 (encode),
  # and /dev/video12 (resize & format conversion) V4L devices.  What we
  # want to look at here is any other V4L device found on the system, such
  # as TV tuners.
  fnBANNER " VIDEO4LINUX DEVICES"
  v4l2-ctl --list-devices 2>/dev/null
  for DEV in $(v4l2-ctl --list-devices 2>/dev/null | grep /dev/)
  do
    fnBANNER " VIDEO4LINUX DEVICE ${DEV}"
    v4l2-ctl -d "${DEV}" --all
    echo
  done
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
fnCAMERA()
{
  fnBANNER " CAMERA (CSI)"
  # Refers to the small cameras that plug into the Pi's CSI connector
  vcgencmd get_camera
  if [[ "$(vcgencmd get_config disable_camera_led | cut -f2 -d"=")" -eq 1 ]]
  then
    echo
    echo "Camera LED is disabled during record."
  fi
  echo
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
fn1W()
{
  local DRIVER

  if [[ -d /sys/bus/w1/devices ]]
  then
    fnBANNER " W1-GPIO (1-WIRE INTERFACE) DRIVERS"
    echo " Loaded Modules..."
    lsmod | grep w1_gpio
    echo
    echo " Discovered 1-WIRE Drivers..."
    find /sys/bus/w1/drivers -type d | grep -v "^.$" | grep -v /drivers$ | while read -r DRIVER
    do
      basename "${DRIVER}"
    done
    echo
    echo " 1-WIRE Addresses in /sys/bus/w1/devices..."
    ls -1 /sys/bus/w1/devices 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
fnSPI()
{
  local DRIVER

  if [[ "$(lsmod | grep spi)" != "" ]]
  then
    fnBANNER " SPI (SERIAL PERIPHERAL INTERFACE) DRIVERS"
    echo " Loaded Modules..."
    lsmod | grep spi
    echo
    echo " Discovered SPI Drivers..."
    find /sys/bus/spi/drivers -type d | grep -v "^.$" | grep -v "/drivers$" | while read -r DRIVER
    do
      basename "${DRIVER}"
    done
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
fnI2S()
{
  local DRIVER

  if [[ "$(lsmod | grep i2s)" != "" ]]
  then
    fnBANNER " I2S (INTER-IC SOUND) DRIVERS"
    echo " Loaded Modules..."
    lsmod | grep i2s
    echo
    echo " Discovered I2S Drivers..."
    find /sys/bus/platform/drivers/*i2s -maxdepth 0 | while read -r DRIVER
    do
      basename "${DRIVER}"
    done
    echo
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER, fnSUB_BANNER
fnI2C()
{
  local DRIVER
  local BUS
  local NUM

  if [[ "$(lsmod | grep i2c)" != "" ]]
  then
    fnBANNER " I2C (INTER-IC COMMUNICATION) DRIVERS"
    echo " Loaded Modules..."
    lsmod | grep i2c
    echo
    echo " Discovered I2C Drivers..."
    find /sys/bus/i2c/drivers -type d | grep -v "^.$\|/drivers$\|/dummy$\|/stmpe-i2c$" | while read -r DRIVER
    do
      basename "${DRIVER}"
    done
    echo
  fi

  # If i2c is enabled, probe for i2c busses
  if [[ "$(grep "^dtparam=i2c_arm=on" /boot/config.txt 2>/dev/null)" != "" ]]
  then
    fnBANNER " I2CDETECT"
    i2cdetect -l 2>&1 | sort
    echo
    i2cdetect -l 2>&1 | sort | awk '{ print $1 }' | cut -f2 -d"-" | while read -r BUS
    do
      echo " I2C BUS: ${BUS}"
      i2cdetect -y "${BUS}" 2>&1
      echo
    done
  fi

  if [[ "$(grep i2c /boot/config.txt 2>/dev/null | grep -v "#")" != "" ]]
  then
    fnSUB_BANNER " I2C-related entries in config.txt"
    grep i2c /boot/config.txt 2>/dev/null | grep -v "^#"
    echo
  fi

  i2cdetect -l | awk '{ print $1 }' | cut -f2 -d"-" | sort -n | while read -r NUM
  do
    echo "-------------------"
    dtoverlay -h i2c"${NUM}" | grep -v "^$"
  done
  echo

  ls -l /dev/i2c*
  echo
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
fnRTC()
{
  # If the user has a realtime clock installed and configured...
  if [[ -c /dev/rtc0 ]] || [[ -L /dev/rtc ]]
  then
    fnBANNER " RTC (REALTIME CLOCK)"
    dmesg | grep rtc | grep -v "Modules linked in:" | grep -v crtc
    echo
    lsmod | grep rtc
    echo
    ls -l /dev/rtc*
    echo
    echo "Hardware RTC says:"
    ${SUDO} hwclock
    echo
    echo "Operating System says:"
    date
    echo
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
fnHWRNG()
{
  # SUPPLEMENTAL STUFF HERE
  # If Hardware Random Number Generator is enabled, and daemon is running...
  if [[ -c /dev/hwrng ]] && [[ -n "$(ps -ef | pgrep rngd)" ]]
  then
    # ...and if the test tool is available...
    if type -path rngtest >/dev/null 2>&1
    then
      fnBANNER " HARDWARE RANDOM NUMBER GENERATOR (***)"
      ${SUDO} cat /dev/hwrng 2>/dev/null | rngtest -c 1000 2>&1
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
fnHWWD()
{
  local DIR

  # SUPPLEMENTAL STUFF HERE
  # If the watchdog timer is enabled...
  if [[ "$(systemctl | grep watchdog.service)" != "" ]]
  then
    fnBANNER " BROADCOM WATCHDOG TIMER (***)"
    dmesg | grep watchdog
    echo
    grep -v "^$\|^#" < /etc/watchdog.conf 2>/dev/null
    echo
    DIR="$(grep "^test-directory" /etc/watchdog.conf 2>/dev/null | awk '{ print $3 }')"
    if [[ -n "${DIR}" ]]
    then
      echo "Contents of ${DIR}:"
      ls -l "${DIR}"
      echo
    fi
    DIR="$(grep "^log-dir" /etc/watchdog.conf 2>/dev/null | awk '{ print $3 }')"
    if [[ -n "${DIR}" ]]
    then
      echo "Contents of ${DIR}:"
      ls -l "${DIR}"
      echo
    fi
    systemctl status watchdog.service | tee /dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
fnUSB_DEV_INFO()
{
  fnBANNER " USB AND OTHER DEVICE INFO"
  lsusb | sort
  echo
  cat /tmp/.lshw_businfo.${PPID} 2>/dev/null
  echo
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
fnLSHW_INPUT()
{
  if [[ -n "${LSHW_INPUT}" ]]
  then
    fnBANNER " INPUT DEVICES"
    ${SUDO} lshw -class input 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
fnLSHW_GENERIC()
{
  if [[ -n "${LSHW_GENERIC}" ]]
  then
    fnBANNER " GENERIC DEVICES"
    ${SUDO} lshw -class generic 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
fnRTL_SDR()
{
  # SUPPLEMENTAL STUFF HERE
  # Note: A bug in the Pi 4B's USB (xhci host controllers that don't update endpoint DCS)
  # may affect test results.  The following commands can update your firmware to
  # correct the issue, if needed:
  # sudo apt update
  # sudo apt install rpi-eeprom
  # sudo rpi-eeprom-update -a
  # sudo reboot
  if type -path rtl_eeprom >/dev/null 2>&1 && type -path rtl_test >/dev/null 2>&1
  then
    if [[ "$(lsmod | grep rtl2832)" != "" ]]
    then
      fnBANNER " RTL-SDR TUNER (***)"
      rtl_eeprom 2>&1
      echo
      rtl_test -t 2>&1 | grep ^S
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
fnLSHW_STORAGE()
{
  if [[ -n "${LSHW_STORAGE}" ]]
  then
    fnBANNER " STORAGE DEVICES"
    ${SUDO} lshw -class storage 2>/dev/null
    echo
    ${SUDO} lshw -short -class disk -class storage -class volume 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER, fnSUB_BANNER
fnSMART()
{
  local DEV
  local MOUNTPOINT
  local NOATIME

  # SUPPLEMENTAL STUFF HERE
  if type -path smartctl >/dev/null 2>&1
  then
    fnBANNER " USB ATA/SATA & SCSI/SAS STORAGE WITH SMART TECHNOLOGY (***)"
    if [[ "$(smartctl --scan -d sat | grep -v aborted)" != "" ]]
    then
      echo "Scanning Devices..."
      smartctl --scan -d sat | grep -v aborted
      echo
      fnSUB_BANNER "Checking \"noatime\" mount option on ATA/SATA and SCSI/SAS filesystems"
      echo "The \"noatime\" option disables updates to the access timestamp of an inode,"
      echo "whenever a file is accessed (eg: when files are merely read.)  Disabling"
      echo "these updates eliminates a huge number of writes to a device over time,"
      echo "especially on filesystems that host the operating system itself.  This is"
      echo "particularly important for SD & SSD devices, as excessive writes will shorten"
      echo "the lifespan of the device.  Mechanical drives can also benefit, from the"
      echo "ever-so-slight performance gain."
      echo
      echo "This check examines mounted filesystems ONLY."
      echo
      smartctl --scan -d sat | grep -v aborted | awk '{ print $1 }' | while read -r DEV
      do
        lsblk --ascii "${DEV}" -o name,mountpoint | grep -v SWAP | grep -v MOUNTPOINT | grep "/" | awk '{ print $NF }' | sort -u | while read -r MOUNTPOINT
        do
          NOATIME="$(grep -v "^#\|^$" < /etc/fstab | awk '{ print $2 " " $4 }' | grep "^${MOUNTPOINT} " | grep "noatime")"
          printf "%-16s" "${MOUNTPOINT}"
          if [[ -n "${NOATIME}" ]]
          then
            echo ": noatime is specified for this filesystem, in /etc/fstab"
          else
            echo ": noatime is not specified for this filesystem, in /etc/fstab"
          fi
        done
      done
      echo
      fnSUB_BANNER "Active statements in /etc/smartd.conf:"
      grep -v "^#\|^$" /etc/smartd.conf
      echo
      fnSUB_BANNER " SMARTD.SERVICE"
      systemctl status smartd.service
      echo
      smartctl --scan -d sat | grep -v aborted | awk '{ print $1 }' | while read -r DEV
      do
        fnBANNER " SMART DEVICE: ${DEV}"
        ${SUDO} smartctl --info "${DEV}" -d sat
        fnSUB_BANNER "Full Device Details..."
        ${SUDO} smartctl -d sat --xall "${DEV}"
      done
    fi
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
fnQUIRKS()
{
  if [[ "$(grep "quirks" /boot/cmdline.txt)" != "" ]]
  then
    fnBANNER " USB STORAGE QUIRKS CHECK"
    echo "USB storage \"quirks\" statement found in cmdline.txt."
    echo "The \"quirks\" directive disables UAS for a given storage device."
    echo "Disabling UAS also disables the trim functions of the device."
    echo "At least one USB storage device may not be capable of \"trim\"."
    echo
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER, fnSUB_BANNER
fnTRIM()
{
  local FSTRIM_STATUS

  if [[ "$(find /etc/udev -type f -exec grep unmap {} \; | grep -v "^#")" != "" ]]
  then
    fnBANNER " USB STORAGE WITH TRIM"
    ${SUDO} fstrim --all -v 2>/dev/null
    FSTRIM_STATUS=${?}
    case ${FSTRIM_STATUS} in
      0|64)
        echo
        fnSUB_BANNER " UDEV RULES FOR TRIM"
        find /etc/udev -type f -exec grep unmap {} \; -print | grep -v "^#"
        echo
        fnSUB_BANNER " FSTRIM.TIMER"
        systemctl status fstrim.timer
        echo
        if [[ "$(grep discard /etc/fstab 2>/dev/null)" != "" ]]
        then
          fnSUB_BANNER " DISCARD ENTRIES IN FSTAB"
          grep discard /etc/fstab 2>/dev/null
          echo
        fi
        ;;
      *)
        ;;
    esac
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
fnBLKID()
{
  fnBANNER " DISK CONFIGURATION"
  ${SUDO} blkid | grep -v zram | sort
  echo
  lsblk -o NAME,FSTYPE,SIZE,MOUNTPOINT,LABEL,UUID,PARTUUID,MODEL | grep -v zram
  echo
  df -h -T | grep -v tmpfs
  echo
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER, fnSUB_BANNER
fnRAID()
{
  local MD
  local UUID
  local FSTAB
  local DEV

  # SUPPLEMENTAL STUFF HERE
  if [[ -e /proc/mdstat ]]
  then
    fnBANNER " RAID ARRAY CONFIGURATION (***)"
    grep "^[a-zA-Z]" < /proc/mdstat 2>/dev/null
    echo
    echo "Contents of /etc/mdadm/mdadm.conf..."
    grep -v "^$\|^#" < /etc/mdadm/mdadm.conf 2>/dev/null
    echo
    grep ^md < /proc/mdstat 2>/dev/null | awk '{ print $1 }' | while read -r MD
    do
      fnSUB_BANNER " RAID ARRAY DEVICE /dev/${MD} (***)" | tr '[:lower:]' '[:upper:]'
      ${SUDO} mdadm --query /dev/"${MD}" 2>/dev/null | sed 's/ Use mdadm --detail for more detail.//'
      echo
      UUID=$(blkid | grep "/dev/${MD}:" | awk '{ print $2 }' | cut -f2 -d"\"")
      FSTAB=$(grep "${UUID}" /etc/fstab 2>/dev/null)
      if [[ -n "${FSTAB}" ]]
      then
        echo "/etc/fstab entry..."
        echo "${FSTAB}"
        echo
        df -h "$(grep "${UUID}" /etc/fstab 2>/dev/null | awk '{ print $2 }')"
        echo
      fi
      ${SUDO} mdadm --detail /dev/"${MD}"
      echo
      ${SUDO} mdadm --detail /dev/"${MD}" | awk '{ print $NF }' | grep /dev/ | grep -v "/dev/${MD}:" | while read -r DEV
      do
        fnSUB_BANNER " RAID ARRAY DEVICE /dev/${MD} - COMPONENT ${DEV} (***)" | tr '[:lower:]' '[:upper:]'
        ${SUDO} mdadm --query "${DEV}" 2>/dev/null | grep -v "is not an md array" | sed 's/  Use mdadm --examine for more detail.//'
        echo
        ${SUDO} mdadm --examine "${DEV}"
        echo
      done
    done
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER, fnSUB_BANNER
fnLVM()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path vgdisplay >/dev/null 2>&1
  then
    if [[ -n "$(${SUDO} vgdisplay 2>/dev/null)" ]]
    then
      fnBANNER " LOGICAL VOLUME MANAGER CONFIGURATION (***)"
      echo "LOGICAL VOLUMES..."
      ${SUDO} lvs 2>&1
      echo
      ${SUDO} lvdisplay 2>&1

      fnSUB_BANNER "VOLUME GROUPS..."
      ${SUDO} vgs 2>&1
      echo
      ${SUDO} vgdisplay 2>&1

      fnSUB_BANNER "PHYSICAL VOLUMES..."
      ${SUDO} pvs 2>&1
      echo
      ${SUDO} pvdisplay 2>&1
    fi
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
fnHDPARM()
{
  local DEV

  # SUPPLEMENTAL STUFF HERE
  if type -path hdparm >/dev/null 2>&1
  then
#   ls -l /dev/sd? | awk '{ print $NF }' | while read -r DEV
    stat /dev/sd? | grep "File:" | awk '{ print $NF }' | while read -r DEV
    do
      fnBANNER " HDPARM ATA/SATA DEVICE PARAMETERS - ${DEV} (***)" | grep -v "^$"
      ${SUDO} hdparm -I --verbose "${DEV}" 2>/dev/null
      echo
    done
  fi
}

#---------------
# Called by fnGROUP_FS_STORAGE
# Calls fnBANNER
fnFSTAB()
{
  if [[ -f /etc/fstab ]]
  then
    fnBANNER " FSTAB FILE"
    grep -v "^$\|^#" < /etc/fstab 2>/dev/null
    echo
  else
    # In truth, I can't envision a booted/running system without this file.
    echo "Missing file /etc/fstab" >&2
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
fnLSHW_MM()
{
  if [[ -n "${LSHW_MULTIMEDIA}" ]]
  then
    fnBANNER " MULTIMEDIA DEVICES"
    ${SUDO} lshw -class multimedia 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
fnALSA_MOD()
{
  if [[ -e /proc/asound/modules ]]
  then
    fnBANNER " ALSA MODULES"
    cat /proc/asound/modules 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
fnALSA_HW()
{
  if [[ -e /proc/asound/cards ]]
  then
    fnBANNER " ALSA SOUND HARDWARE"
    cat /proc/asound/cards 2> /dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
fnALSA_CARD()
{
  if [[ -e /proc/asound/cards ]]
  then
    grep "^ [0123]" < /proc/asound/cards 2>/dev/null | awk '{ print $1 }' | while read -r CARD_NUM
    do
      fnBANNER " ALSA CARD-${CARD_NUM} INFO"
      amixer -c "${CARD_NUM}" 2>/dev/null
      echo
    done
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
fnALSA_PB_CAP()
{
  fnBANNER " ALSA PLAYBACK AND CAPTURE DEVICES"
  if [[ "$(aplay -l 2>/dev/null | grep ^card)" != "" ]]
  then
    aplay -l 2>/dev/null
  else
    aplay -l 2>/dev/null | grep PLAYBACK
    echo "No playback device found"
  fi
  echo
  if [[ "$(arecord -l 2>/dev/null | grep ^card)" != "" ]]
  then
    arecord -l 2>/dev/null
  else
    arecord -l 2>/dev/null | grep CAPTURE
    echo "No capture device found"
  fi
  echo
}

#---------------
# Called by fnGROUP_SERIAL_BT
# Calls fnBANNER
fnACM()
{
  if [[ -c /dev/ttyACM0 ]] || [[ -c /dev/ttyACM1 ]]
  then
    if [[ -n "${LSHW_COMMUNICATION}" ]]
    then
      fnBANNER " ACM COMMUNICATION DEVICES"
      ${SUDO} lshw -class communication 2>/dev/null
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_SERIAL_BT
# Calls fnBANNER, fnSUB_BANNER
fnSERIAL()
{
  local SERIAL_DEV
  local NUM
  local UART_TYPE
  local DEVICE

  fnBANNER " UARTS AND USB SERIAL PORTS"
  # By default, on Raspberry Pis equipped with wireless/Bluetooth module,
  # (Raspberry Pi 3 and Raspberry Pi Zero W), the PL011 UART is connected
  # to the Bluetooth module, while the mini UART is used as the primary
  # UART and will have a Linux console on it.  On all other models, the
  # PL011 is used as the primary UART.
  #
  # In Linux device terms, by default, /dev/ttyS0 refers to the mini UART,
  # and /dev/ttyAMA0 refers to the PL011.  The primary UART is the one
  # assigned to the Linux Console, which depends on the Raspberry Pi model
  # as described above.  There are also symlinksi: /dev/serial0, which
  # always refers to the primary UART (if enabled), and /dev/serial1,
  # which similarly always refers to the secondary UART (if enabled.)
  #
  # The Pi 4 allows up to 4 additional hardware UARTS (2 thru 5) to be defined.
  # uart2 uses pins that could conflict with the camera and any kind of "hat" with eerom.
  #   Also If you enable the handshake, I2C1 has to be disabled.
  # uart3 use GPIO4 then you should consider to change 1 wire GPIO pin if you need 1 wire.
  #   It also uses GPIO7 if you enable handshake then you need to disable SPI.
  # uart4 uses the SPI GPIOs.  SPI needs to be disabled.
  # No conflict with uart5. This is the safest one to use.

  # IN OTHER WORDS:
  # On all Pis, UART0 is a PL011 that appear to Linux as ttyAMA<n>,
  # and UART1 is an 8250 clone that appears as ttyS0.  On a Pi4,
  # UART2-5 are additional PL011s that also appear as ttyAMA<n>.
  # The number starts at 0 for the first enabled PL011 and counts
  # up through all the enabled interfaces.  The numbering is stable
  # for any given combination of UARTs, but enabling or disabling
  # one can change the number assignments of others.
  #
  # Adding "enable_uart=1" to config.txt on a Pi4 enables ttyS0 (UART1)
  # on GPIOs 14 & 15 (Alt5), leaving UART0 driving the Bluetooth
  # interface on 30-33 (Alt3).  Adding "dtoverlay=disable-bt" switches
  # the UART roles so that UART0 is mapped to 14 & 15 (Alt0), leaving
  # UART1 unmapped.

  ls -l /dev/ttyAMA? /dev/serial? /dev/ttyS? /dev/ttyACM? 2>/dev/null
  echo

  fnSUB_BANNER " On-board (non-USB) serial ports"
  dmesg | grep MMIO | awk '{ print $4 }' | while read -r MMIO
  do
    SERIAL_DEV="$(dmesg | grep "${MMIO}" | cut -f2 -d":" | cut -f2 -d")" | sed 's/is a//')"
    echo -e "${MMIO}\t: ${SERIAL_DEV}"
  done
  echo

  if [[ "$(grep uart /boot/config.txt 2>/dev/null | grep -v "#")" != "" ]]
  then
    fnSUB_BANNER " UART-related entries in config.txt"
    grep uart /boot/config.txt 2>/dev/null | grep -v "^#"
    echo
  fi

  grep "^dtoverlay=uart" /boot/config.txt 2>/dev/null | cut -f2 -d"=" | cut -f1 -d"," | cut -c 5 | while read -r NUM
  do
    fnSUB_BANNER " 4B UART #${NUM}"
    dtoverlay -h uart"${NUM}" | grep -v "^$"
    echo
    raspi-gpio get 0-15 | grep -v PUT | awk '{ print $1" "$2" "$6 }' | grep "${NUM}$"
    echo
  done

  for NUM in 0 1 2 3 4 5
  do
    if [[ -c /dev/ttyACM${NUM} ]]
    then
      UART_TYPE=$(dmesg | grep ttyACM${NUM} | cut -f4 -d":" | cut -c2-)
      DEVICE=": $(systemctl list-units --all | grep dev-ttyACM${NUM}.device | sed 's/plugged/plugged:/' | cut -f2- -d":" | sed 's/   //')"
      fnSUB_BANNER " /dev/ACM${NUM}... ${UART_TYPE}${DEVICE}"
      stty -a -F /dev/ttyACM${NUM}
      echo
    fi
  done
  for NUM in 0 1 2 3 4 5
  do
    if [[ -c /dev/ttyAMA${NUM} ]]
    then
      fnSUB_BANNER " /dev/ttyAMA${NUM}..."
      stty -a -F /dev/ttyAMA${NUM}
      echo
    fi
  done
  for NUM in 0 1 2 3 4 5
  do
    if [[ -c /dev/ttyS${NUM} ]]
    then
      fnSUB_BANNER " /dev/ttyS${NUM}..."
      stty -a -F /dev/ttyS${NUM}
      echo
    fi
  done
}

#---------------
# Called by fnGROUP_SERIAL_BT
# Calls fnBANNER
fnBT()
{
  local PS_BT
  local BTMAC_OUT
  local BTDEFAULT
  local BTMAC
  local BTSHOW_OUT
  local BTPAIRED_OUT

  # Make sure bluetoothd is running, because if not,
  # the bluetoothctl commands used here will hang.
  PS_BT=$(pgrep bluetoothd)
  if [[ -n "${PS_BT}" ]]
  then
    #---------------
    fnBANNER " BLUETOOTH CONTROLLERS"
    hciconfig
    BTMAC_OUT="$(echo list | ${SUDO} bluetoothctl 2>/dev/null)"
    BTDEFAULT=$(echo "${BTMAC_OUT}" | grep ^Controller | grep "default" | awk '{ print $2 }')
    BTMAC=""
    echo "${BTMAC_OUT}" | grep ^Controller | awk '{ print $2 }' | while read -r BTMAC
    do
      if [[ "${BTDEFAULT}" = "${BTMAC}" ]]
      then
        echo "Default BT Controller..."
      else
        echo "Additional (Non-default) BT Controller..."
      fi
      BTSHOW_OUT="$(echo show "${BTMAC}" | ${SUDO} bluetoothctl 2>/dev/null)"
      echo "${BTSHOW_OUT}" | grep -v "\[" | grep -v "^$" | grep -v "Agent registered" | grep -v "Device registered not available"
      echo
    done
    #---------------
    fnBANNER " BLUETOOTH DEVICES (paired w/ default controller)"
    BTPAIRED_OUT="$(echo paired-devices | ${SUDO} bluetoothctl 2>/dev/null)"
    if [[ -n "${BTPAIRED_OUT}" ]]
    then
      echo "${BTPAIRED_OUT}" | grep -v "\[" | awk '{ print $2 }' | while read -r BTMAC
      do
        echo "info ${BTMAC}" | ${SUDO} bluetoothctl 2>/dev/null | grep -v "\[" | grep -v "^$" | grep -v "Agent registered" | grep -v "Device registered not available"
      done
      echo
    fi
  else
    #---------------
    fnBANNER " bluetoothd daemon not running"
    echo
  fi
}

#---------------
# Called by fnGROUP_MEMORY
# Calls fnBANNER
fnMEMSWAP()
{
  fnBANNER " MEMORY AND SWAP"
  free -h
  echo
  swapon --summary
  echo
}

#---------------
# Called by fnGROUP_MEMORY
# Calls fnBANNER
fnMEMINFO()
{
  if [[ -e /proc/meminfo ]]
  then
    fnBANNER " MEMINFO"
    cat /proc/meminfo 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_MEMORY
# Calls fnBANNER
fnIPC()
{
  fnBANNER " IPC STATUS"
  lsipc
  echo
  ipcs -u
  ipcs -m
  ipcs -q
  ipcs -s
  ipcs -l
}

#---------------
# Called by fnGROUP_LOGGING
# Calls fnBANNER
fnDMESG()
{
  fnBANNER " DMESG - WARNINGS"
  dmesg | grep -i warn
  echo
  fnBANNER " DMESG - FAILURES"
  dmesg | grep -i fail
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
fnSYSTEMD_CHAIN()
{
  fnBANNER " SYSTEMD-ANALYZE CRITICAL-CHAIN"
  systemctl list-jobs
  echo
  systemd-analyze time
  echo
  systemd-analyze critical-chain
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
fnSYSTEMD_BLAME()
{
  fnBANNER " SYSTEMD-ANALYZE BLAME"
  # the tee eliminates the pause every screenfull
  systemd-analyze blame | tee /dev/null
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
fnSYSCTL_STATUS()
{
  fnBANNER " SYSTEMCTL STATUS"
  # the tee eliminates the pause every screenfull
  systemctl status | tee /dev/null
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
fnSYSCTL_FAIL()
{
  fnBANNER " SYSTEMCTL UNIT FAILURES"
  systemctl list-units --failed --all | grep -v "list-unit-files"
  echo
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
fnSYSCTL_LIST()
{
  fnBANNER " SYSTEMCTL LIST-UNIT-FILES"
  # the tee eliminates the pause every screenfull
  systemctl list-unit-files | tee /dev/null
  echo
}

#---------------
# Called by fnGROUP_LOGGING
# Calls fnBANNER
fnJOURNAL()
{
  if [[ -d /var/log/journal ]]
  then
    if [[ "$(stat /var/log/journal | grep "Access" | grep "2755" | grep "root" | grep "systemd")" != "" ]]
    then
      fnBANNER " PERSISTENT JOURNALING"
      echo "Persistent Journaling is configured"
      ls -ld /var/log/journal
      echo
      ${SUDO} journalctl --sync
      ${SUDO} journalctl --flush
      ${SUDO} journalctl -b | grep "System journal"  | tail -1 | cut -f4- -d":"
      ${SUDO} journalctl -b | grep "Runtime journal" | tail -1 | cut -f4- -d":" | sed 's/^ //'
      echo
      echo "Journaled boots..."
      journalctl --list-boots
      echo
      journalctl --disk-usage
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_LOGGING
# Calls fnBANNER
fnRSYSLOG()
{
  local PERL_SCRIPT

  # SUPPLEMENTAL STUFF HERE
  # Logic in this module is shamelessly based on syslogconf,
  # by Michael Hill, Lockheed Martin Astronotics, Denver, CO
  # Perl is used here because bash sucks at nesting associative arrays.
  if type -path perl >/dev/null 2>&1 && type -path m4 >/dev/null 2>&1
  then
    fnBANNER " RSYSLOG.CONF ANALYSIS (***)"
    echo "This module creates a comprehensive listing of rsyslog.conf event logging."
    echo "The selector selects all messages of equal or higher severity.  For example,"
    echo "news.err really means news.err, news.crit, news.alert, news.emerg.  And"
    echo "mail,uucp.alert means mail.alert, mail.emerg, uucp.alert, and uucp.emerg."
    echo
    echo "Some versions of syslog allow an = character before the level specifier"
    echo "(as in news.=err) to act only on messages of that level."
    echo
    echo "The output below interprets the directives to show where things are going."
    echo

    PERL_SCRIPT=$(cat <<'EOF'
select (STDERR); $| = 1;        # Turn off buffered I/O
select (STDOUT); $| = 1;
($progname = $0) =~ s/.*\///;
chop ($uname = `uname -nsr`);
@uname = split (' ', $uname);

sub fatal {
  local ($errMesg, $errCode) = (@_);

  printf (STDERR "$progname:  %s\n", $errMesg);
  exit ($errCode);
}

$rsyslogconf = '/etc/rsyslog.conf';
$loghost = '';
@facilities = ('kern', 'user', 'mail', 'daemon',
  'auth', 'lpr', 'news', 'uucp', 'cron', 'local0',
  'local1', 'local2', 'local3', 'local4', 'local5',
  'local6', 'local7', 'mark');
@levels = ('emerg', 'alert', 'crit', 'err', 'warning',
  'notice', 'info', 'debug');

for $facil (@facilities) {
  for $lev (@levels) {
    $event_type{"$facil.$lev"} = 'no action';
  }
}
for $i ($[ .. $#levels) {
  $severity{$levels[$i]} = $i;
}

($name) = gethostbyname ('loghost');
if ($name eq $hostname) {
  # we're running on 'loghost'
  $loghost = '-DLOGHOST';
}

open (SYSLOGCONF, "m4 $loghost $rsyslogconf |") ||
  &fatal ("can't open 'm4 $rsyslogconf'", 2);

while (<SYSLOGCONF>) {
  local (%eventlist);

  next if (/^\s*$/ || /^\s*#/);
  chop;

  %eventlist = ( );
  ($events, $action) = split (/\t+/);
  next if ($action eq '');

  # parse for multiple events
  @events = split (';', $events);
  for $event (@events) {
    local ($thislev, $evt);

    ($facils, $level) = split ('\.', $event);
    $thislev = $severity{$level};

    # parse for multiple facility specifications
    if ($facils eq '*') {
      @facils = grep (! /mark/, @facilities);
    } else {
      @facils = split (',', $facils);
    }
    if ($level eq 'none') {
      @levs = @levels;
    } else {
      @levs = grep ($severity{$_} <= $thislev, @levels);
    }
    for $facil (@facils) {
      for $lev (@levs) {
        if ($level eq 'none') {         # delete entry
          delete ($eventlist{"$facil.$lev"})
            if ($eventlist{"$facil.$lev"});
        } else {                        # add entry
          $eventlist{"$facil.$lev"} = 1;
        }
      }
    }
  }
  for $evt (keys (%eventlist)) {
    if ($event_type{$evt} eq 'no action') {
      $event_type{$evt} = $action;
    } else {
      $event_type{$evt} .= ", $action";
    }
  }
}

close (SYSLOGCONF);

for $key (sort (keys (%event_type))) {
  printf ("Event:  %-16s\tAction:  %s\n", $key,
    $event_type{$key});
}

exit (0);
EOF
  )
  perl -e "${PERL_SCRIPT}"
  echo
  fi
}

#---------------
# Called by fnGROUP_LOGGING
# Calls fnBANNER
fnLOGROTATE()
{
  fnBANNER " LOGROTATE"
  echo " Contents of /etc/logrotate.conf:"
  grep -v "^$" /etc/logrotate.conf
  echo
  echo " ----------------------------------------------------"
  echo " logrotate config files in /etc/logrotate.d ..."
  ls /etc/logrotate.d
  echo
  if [[ "$(systemctl | grep "logrotate.timer")" != "" ]]
  then
    echo " ----------------------------------------------------"
    systemctl status logrotate.timer
    echo
  fi
}

#---------------
# Called by fnGROUP_OS_SERVICES
# Calls fnBANNER
fnRCLOCAL()
{
  if [[ -f /etc/rc.local ]]
  then
    fnBANNER " CONTENTS OF RC.LOCAL"
    grep -v "^$\|^#" < /etc/rc.local 2>/dev/null
    echo
  else
    echo "Missing file /etc/rc.local" >&2
  fi
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
fnLOCALE()
{
  if [[ -f /etc/default/locale ]] && [[ -f /etc/default/keyboard ]] && [[ -f /etc/default/console-setup ]] && [[ -f /etc/timezone ]]
  then
    fnBANNER " LOCALIZATION SETTINGS"
    . /etc/default/locale
    . /etc/default/keyboard
    . /etc/default/console-setup
    echo "Language : ${LANG}"
    echo "KB Model : ${XKBMODEL}"
    echo "KB Layout: ${XKBLAYOUT}"
    echo "Char. Map: ${CHARMAP}"
    echo "Timezone : $(cat /etc/timezone 2>/dev/null)"
    echo
  else
    echo "Unable to determine locale settings on this Pi.  Skipping."
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER, fnSUB_BANNER
fnLIRC()
{
  local LIRC
  local SERVICE

  # SUPPLEMENTAL STUFF HERE
  if [[ -n "$(find /dev/lirc* -print 2>/dev/null)" ]]
  then
    fnBANNER " LIRC - LINUX INFRA-RED COMMUNICATION DEVICES (***)"
    lsmod | grep "ir_" | sort
    echo

    fnSUB_BANNER " LIRC-related entries in config.txt"
    grep gpio-ir /boot/config.txt 2>/dev/null | grep -v "^#"
    echo

    fnSUB_BANNER " LIRC config files"
    find /etc/lirc* -print | grep conf$
    echo

    fnSUB_BANNER " LIRC device nodes"
    find /dev/lirc* -print | while read -r LIRC
    do
      ls -l "${LIRC}"
    done
    echo

    fnSUB_BANNER " LIRC device tree overlays"
    if [[ -c /dev/lirc0 ]]
    then
      dtoverlay -h gpio-ir 2> /dev/null | grep -v "^$"
      echo
    fi
    if [[ -c /dev/lirc1 ]]
    then
      dtoverlay -h gpio-ir-tx 2> /dev/null | grep -v "^$"
      echo
    fi

    fnSUB_BANNER " LIRC dmesg log entries"
    dmesg | grep lirc | cut -f2- -d"]"
    echo

    fnSUB_BANNER " LIRC service status entries"
    for SERVICE in $(systemctl | grep lirc | awk '{ print $1 }')
    do
      systemctl status "${SERVICE}"
      echo
    done
    echo
  fi
}

#---------------
# Called by fnGROUP_DEVICES
# Calls fnBANNER
fnPRINTER()
{
  local CUPS_RUNNING

  # SUPPLEMENTAL STUFF HERE
  # Not everyone has "cups" installed, so "lpstat" (part of the cups-client package)
  # is not a required dependency for this script.  If they have it, great.  If not,
  # it's no big deal.
  if type -path lpstat >/dev/null 2>&1
  then
    CUPS_RUNNING="$(lpstat -r 2>/dev/null)"
    if [[ "${CUPS_RUNNING}" = "scheduler is running" ]]
    then
      fnBANNER " PRINTER STATUS {***)"
      lpstat -t
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
fnTOUCH()
{
  local PI_TOUCHSCR

  fnBANNER " OFFICIAL 7\" TOUCHSCREEN"
  PI_TOUCHSCR="$(dmesg | grep -i ft5406)"
  if [[ -n "${PI_TOUCHSCR}" ]]
  then
    echo "detected"
  else
    echo "not detected"
  fi
  echo
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER, fnSUB_BANNER
fnDISPLAY()
{
  local DISP_NUM
  local TVSTATUS
  local TV_OFF
  local DEV_ID
  local DEV_AUDIO
  local TVGROUP

  if [[ "${VERSION_ID}" -ne 9 ]]
  then
    # It seems that Stretch doesn't support the "-1" flag
    # for "vcgencmd display_power", to test specific displays.
    # So, skip this first section, if Stretch.
    fnBANNER " DISPLAY POWER UP STATUS"
    echo "DISPLAY         ID  STATUS"
    echo "--------------------------"
    echo -e -n "Main LCD        0"
    case $(vcgencmd display_power -1 0 | cut -f2 -d"=") in
      "0") echo "   off"
          ;;
      "1") echo "   ON"
          ;;
        *) echo "   undetected"
          ;;
    esac
    echo -e -n "Secondary LCD   1"
    case $(vcgencmd display_power -1 1 | cut -f2 -d"=") in
      "0") echo "   off"
          ;;
      "1") echo "   ON"
          ;;
        *) echo "   undetected"
          ;;
    esac
    echo -e -n "HDMI 0          2"
    case $(vcgencmd display_power -1 2 | cut -f2 -d"=") in
      "0") echo "   off"
          ;;
      "1") echo "   ON"
          ;;
        *) echo "   undetected"
          ;;
    esac
    echo -e -n "Composite       3"
    case $(vcgencmd display_power -1 3 | cut -f2 -d"=") in
      "0") echo "   off"
          ;;
      "1") echo "   ON"
          ;;
        *) echo "   undetected"
          ;;
    esac
    echo -e -n "HDMI 1          7"
    case $(vcgencmd display_power -1 7 | cut -f2 -d"=") in
      "0") echo "   off"
          ;;
      "1") echo "   ON"
          ;;
        *) echo "   undetected"
          ;;
    esac
    echo
  fi

  # Unfortunately, tvservice is useless with vc4-kms-v3d(-pi4),
  # but ok with broadcom and "fake" gl driver.
  if [[ "${DISP_DRIVER}" = "broadcom" ]] || [[ "${DISP_DRIVER}" = "fake" ]]
  then
    fnBANNER " HDMI DISPLAY DATA"
    vcgencmd dispmanx_list 2>&1
    echo
    tvservice -l 2>/dev/null
    echo
    tvservice -l 2>/dev/null | grep "Display Number" | awk '{ print $3 }' | cut -f1 -d"," | while read -r DISP_NUM
    do
      TVSTATUS="$(tvservice -s -v "${DISP_NUM}" 2>/dev/null | strings)"
      TV_OFF="$(echo "${TVSTATUS}" | awk '{ print $2 }')"
      if [[ "${TV_OFF}" = "0x120000" ]]
      then
        echo "Display ${DISP_NUM} is not HDMI... Skipping."
        echo
        continue
      else
        if [[ "${TV_OFF}" = "0x2" ]]
        then
          echo "Display ${DISP_NUM} TV is Off... Skipping."
          echo
          continue
        fi
      fi
      fnSUB_BANNER "DISPLAY NUMBER : ${DISP_NUM}"
      echo "DISPLAY STATUS : ${TVSTATUS}"

      DEV_ID="$(tvservice -n -v "${DISP_NUM}" 2>/dev/null | strings )"
      if [[ "${DEV_ID}" = "" ]]
      then
        DEV_ID="No Device Present"
      fi
      echo "EDID DEVICE ID : ${DEV_ID}"

      DEV_AUDIO="$(tvservice -a -v "${DISP_NUM}" 2>/dev/null | strings | sed 's/^     //')"
      if [[ "${DEV_AUDIO}" = "" ]]
      then
        DEV_AUDIO="No Device Present"
      fi
      echo "SUPPORTED AUDIO: ${DEV_AUDIO}"
      echo

      # Group is usually either DMT (monitors - group 2) or CEA (TV sets - group 1)
      # This forces "custom" modes to be listed (I hope) as DMT, mode 87
      TVGROUP="$(echo "${TVSTATUS}" | awk '{ print $4 }')"
      if [[ "${TVGROUP}" != "DMT" ]] && [[ "${TVGROUP}" != "CEA" ]]
      then
        TVGROUP=DMT
      fi
      tvservice --modes=${TVGROUP} -v "${DISP_NUM}" 2>/dev/null
      echo
    done
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
fnROWS_COLS()
{
  local ROWS
  local COLS

  fnBANNER " CURRENT ROWS & COLUMNS"
  echo "Term type is: ${TERM}"
  echo
  if [[ "${TERM}" = "" ]] || [[ "${TERM}" = "dumb" ]]
  then
    echo "Environment variable TERM not defined."
    echo "Unable to determine rows and columns."
  else
    ROWS=$(tput lines 2>/dev/null)
    COLS=$(tput cols 2>/dev/null)
    echo "Screen is ${ROWS} rows X ${COLS} columns"
    echo
    echo "Term type characteristics from infocomp"
    echo "---------------------------------------"
    infocmp -I "${TERM}"
    echo
    echo "Term type characteristics from termcap"
    echo "---------------------------------------"
    infocmp -C "${TERM}"
  fi
  echo
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
fnRESOLUTION()
{
  # 'vcgencmd get_lcd_info' is useless with vc4-kms-v3d(-pi4), but
  # ok with broadcom and "fake" gl driver.
  if [[ "${DISP_DRIVER}" = "broadcom" ]] || [[ "${DISP_DRIVER}" = "fake" ]]
  then
    fnBANNER " CURRENT SCREEN RESOLUTION"
    echo "HORIZONTAL : $(vcgencmd get_lcd_info | awk '{ print $1 }') pixels"
    echo "VERTICAL   : $(vcgencmd get_lcd_info | awk '{ print $2 }') pixels"
    echo "COLOR DEPTH: $(vcgencmd get_lcd_info | awk '{ print $3 }') bits"
    echo
  fi
}

#---------------
# Called by fnGROUP_AV
# Calls fnBANNER
fnXRESOLUTION()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path xrandr >/dev/null 2>&1
  then
    if [[ -n "${DISPLAY}" ]]
    then
      fnBANNER " CURRENT X-DISPLAY RESOLUTION (***)"
      echo "\$DISPLAY=${DISPLAY}"
      # xrandr is part of package "x11-xserver-utils"
      xrandr --verbose 2>&1 | grep -v "xrandr: Failed to get size of gamma for output default"
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
fnWIRINGPI()
{
  # SUPPLEMENTAL STUFF HERE
  # Do not run on Pi 4B 8GB model.
  # All other Pi 4Bs (1/2/4GB) require WiringPi version 2.52.
  # All older Pi models can run the versions in the repositories.
  if type -path gpio >/dev/null 2>&1 && [[ "${MY_REVISION}" != "d03114" ]]
  then
    fnBANNER " GPIO PIN STATUS via WIRINGPI (***)"
    if [[ "${MY_MODEL_NAME}" = "4B" ]] && [[ "${WIRINGPI_VERS}" = "2.52" ]]
    then
      gpio readall
      echo
    fi
    if [[ "${MY_MODEL_NAME}" != "4B" ]]
    then
      gpio readall
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_HW_BUSSES
# Calls fnBANNER
fnPIGPIOD()
{
  local PY3_SCRIPT

  # SUPPLEMENTAL STUFF HERE
  # See: http://www.raspberrypi.org/forums/viewtopic.php?t=254071
  # for post entitled "GPIO Readall Code", by user "Milliways"
  # requires python3-pigpio be installed.
  # requires "/usr/bin/pigpiod" be running (systemctl enable pigpiod.service)
  # Unfortunately, some older 26-pin Model A and B Pis may be out of luck.
  if [[ -n "$(pgrep pigpiod)" ]]
  then
    fnBANNER " GPIO PIN STATUS via PIGPIOD (***)"
    PY3_SCRIPT=$(cat <<'EOF'
"""
Read all GPIO
"""
import sys, os, time
import pigpio

MODES = ["IN", "OUT", "ALT5", "ALT4", "ALT0", "ALT1", "ALT2", "ALT3"]
HEADER = ('3.3v', '5v', 2, '5v', 3, 'GND', 4, 14, 'GND', 15, 17, 18, 27, 'GND', 22, 23, '3.3v', 24, 10, 'GND', 9, 25, 11, 8, 'GND', 7, 0, 1, 5, 'GND', 6, 12, 13, 'GND', 19, 16, 26, 20, 'GND', 21)
GPIOPINS = 40

FUNCTION = {
'Pull': ('High', 'High', 'High', 'High', 'High', 'High', 'High', 'High', 'High', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low', 'Low'),
'ALT0': ('SDA0', 'SCL0', 'SDA1', 'SCL1', 'GPCLK0', 'GPCLK1', 'GPCLK2', 'SPI0_CE1_N', 'SPI0_CE0_N', 'SPI0_MISO', 'SPI0_MOSI', 'SPI0_SCLK', 'PWM0', 'PWM1', 'TXD0', 'RXD0', 'FL0', 'FL1', 'PCM_CLK', 'PCM_FS', 'PCM_DIN', 'PCM_DOUT', 'SD0_CLK', 'SD0_XMD', 'SD0_DATO', 'SD0_DAT1', 'SD0_DAT2', 'SD0_DAT3'),
'ALT1': ('SA5', 'SA4', 'SA3', 'SA2', 'SA1', 'SAO', 'SOE_N', 'SWE_N', 'SDO', 'SD1', 'SD2', 'SD3', 'SD4', 'SD5', 'SD6', 'SD7', 'SD8', 'SD9', 'SD10', 'SD11', 'SD12', 'SD13', 'SD14', 'SD15', 'SD16', 'SD17', 'TE0', 'TE1'),
'ALT2': ('PCLK', 'DE', 'LCD_VSYNC', 'LCD_HSYNC', 'DPI_D0', 'DPI_D1', 'DPI_D2', 'DPI_D3', 'DPI_D4', 'DPI_D5', 'DPI_D6', 'DPI_D7', 'DPI_D8', 'DPI_D9', 'DPI_D10', 'DPI_D11', 'DPI_D12', 'DPI_D13', 'DPI_D14', 'DPI_D15', 'DPI_D16', 'DPI_D17', 'DPI_D18', 'DPI_D19', 'DPI_D20', 'DPI_D21', 'DPI_D22', 'DPI_D23'),
'ALT3': ('SPI3_CE0_N', 'SPI3_MISO', 'SPI3_MOSI', 'SPI3_SCLK', 'SPI4_CE0_N', 'SPI4_MISO', 'SPI4_MOSI', 'SPI4_SCLK', '_', '_', '_', '_', 'SPI5_CE0_N', 'SPI5_MISO', 'SPI5_MOSI', 'SPI5_SCLK', 'CTS0', 'RTS0', 'SPI6_CE0_N', 'SPI6_MISO', 'SPI6_MOSI', 'SPI6_SCLK', 'SD1_CLK', 'SD1_CMD', 'SD1_DAT0', 'SD1_DAT1', 'SD1_DAT2', 'SD1_DAT3'),
'ALT4': ('TXD2', 'RXD2', 'CTS2', 'RTS2', 'TXD3', 'RXD3', 'CTS3', 'RTS3', 'TXD4', 'RXD4', 'CTS4', 'RTS4', 'TXD5', 'RXD5', 'CTS5', 'RTS5', 'SPI1_CE2_N', 'SPI1_CE1_N', 'SPI1_CE0_N', 'SPI1_MISO', 'SPIl_MOSI', 'SPI1_SCLK', 'ARM_TRST', 'ARM_RTCK', 'ARM_TDO', 'ARM_TCK', 'ARM_TDI', 'ARM_TMS'),
'ALT5': ('SDA6', 'SCL6', 'SDA3', 'SCL3', 'SDA3', 'SCL3', 'SDA4', 'SCL4', 'SDA4', 'SCL4', 'SDA5', 'SCL5', 'SDA5', 'SCL5', 'TXD1', 'RXD1', 'CTS1', 'RTS1', 'PWM0', 'PWM1', 'GPCLK0', 'GPCLK1', 'SDA6', 'SCL6', 'SPI3_CE1_N', 'SPI4_CE1_N', 'SPI5_CE1_N', 'SPI6_CE1_N')
}

def pin_state(g):
    mode = pi.get_mode(g)
    if(mode<2):
        name = 'GPIO{}'.format(g)
    else:
        name = FUNCTION[MODES[mode]][g]
    return name, MODES[mode], pi.read(g)

if len(sys.argv) > 1:
    pi = pigpio.pi(sys.argv[1])
else:
    pi = pigpio.pi()

if not pi.connected:
    sys.exit(1)
rev = pi.get_hardware_revision()
if rev < 16 :
    GPIOPINS = 26

print('+-----+------------+------+---+----++----+---+------+-----------+-----+')
print('| BCM |    Name    | Mode | V |  Board   | V | Mode | Name      | BCM |')
print('+-----+------------+------+---+----++----+---+------+-----------+-----+')
for h in range(1, GPIOPINS, 2):
# odd pin
    hh = HEADER[h-1]
    if(type(hh)==type(1)):
        print('|{0:4} | {1[0]:<10} | {1[1]:<4} | {1[2]} |{2:3} '.format(hh, pin_state(hh), h), end='|| ')
    else:
        print('|     |  {:18}   | {:2}'.format(hh, h), end=' || ')
# even pin
    hh = HEADER[h]
    if(type(hh)==type(1)):
        print('{0:2} | {1[2]:<2}| {1[1]:<5}| {1[0]:<10}|{2:4} |'.format(h+1, pin_state(hh), hh))
    else:
        print('{:2} |             {:9}|     |'.format(h+1, hh))
print('+-----+------------+------+---+----++----+---+------+-----------+-----+')
print('| BCM |    Name    | Mode | V |  Board   | V | Mode | Name      | BCM |')
print('+-----+------------+------+---+----++----+---+------+-----------+-----+')
EOF
  )
    python3 -c "${PY3_SCRIPT}"
    echo
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
fnMPSTAT()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path mpstat >/dev/null 2>&1
  then
    fnBANNER " MPSTAT (***)"
    # 3 samples, 3 seconds apart, to get an average
    mpstat 3 3
    echo
  else
    echo "Missing utility mpstat (part of sysstat), skipping mpstat display" >&2
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
fnIOSTAT()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path iostat >/dev/null 2>&1
  then
    fnBANNER " IOSTAT (***)"
    iostat -x
  else
    echo "Missing utility iostat (part of sysstat), skipping iostat display" >&2
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
fnIP6STAT()
{
  if [[ "$(grep ipv6.disable=1 /boot/cmdline.txt 2>/dev/null)" != "" ]]
  then
    fnBANNER " IPV6 DISABLED"
    echo "IPv6 has been disabled in cmdline.txt"
    echo
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
fnNET_FILES()
{
  local HITS

  if [[ -f /etc/resolv.conf ]]
  then
    fnBANNER " RESOLV.CONF"
    grep -v "^$\|^#" < /etc/resolv.conf 2>/dev/null
    echo
  else
    echo "Missing file /etc/resolv.conf" >&2
  fi

  if [[ -f /etc/hosts ]]
  then
    fnBANNER " HOSTS FILE"
    grep -v "^$\|^#" < /etc/hosts 2>/dev/null
    echo
  else
    echo "Missing file /etc/hosts" >&2
  fi

  if [[ -f /etc/networks ]]
  then
    fnBANNER " NETWORKS FILE"
    grep -v "^$\|^#" < /etc/networks 2>/dev/null
    echo
  else
    echo "Missing file /etc/networks" >&2
  fi

  if [[ -f /etc/iptables.up.rules ]]
  then
    fnBANNER " IPV4 FIREWALL RULES"
    grep -v "^$\|^#" < /etc/iptables.up.rules 2>/dev/null
    echo
  else
    echo "Missing file /etc/iptables.up.rules" >&2
  fi

  if [[ -f /etc/ip6tables.up.rules ]]
  then
    fnBANNER " IPV6 FIREWALL RULES"
    grep -v "^$\|^#" < /etc/ip6tables.up.rules 2>/dev/null
    echo
  else
    echo "Missing file /etc/ip6tables.up.rules" >&2
  fi

  if [[ -f /etc/hosts.deny ]]
  then
    fnBANNER " TCPWRAPPERS: HOSTS.DENY"
    HITS=$(grep -v "^$\|^#" < /etc/hosts.deny 2>/dev/null | grep -c .)
    if [[ "${HITS}" -ne 0 ]]
    then
      grep -v "^#\|^$" < /etc/hosts.deny 2>/dev/null
    else
      echo "file is empty"
    fi
    echo
  else
    echo "Missing file /etc/hosts.deny" >&2
  fi

  if [[ -f /etc/hosts.allow ]]
  then
    fnBANNER " TCPWRAPPERS: HOSTS.ALLOW"
    HITS=$(grep -v "^#\|^$" < /etc/hosts.allow 2>/dev/null | grep -c .)
    if [[ "${HITS}" -ne 0 ]]
    then
      grep -v "^#\|^$" < /etc/hosts.allow 2>/dev/null
    else
      echo "file is empty"
    fi
    echo
  else
    echo "Missing file /etc/hosts.allow" >&2
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
fnROUTES()
{
  fnBANNER " ROUTE TABLE - IPV4"
  route -4 2> /dev/null
  echo
  fnBANNER " ROUTE TABLE - IPV6"
  route -6 2> /dev/null
  echo
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
fnNET_ADAPTERS()
{
  fnBANNER " NETWORK ADAPTERS"
  ${SUDO} lshw -class network 2>/dev/null
  echo
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
fnETHTOOL()
{
  local ETH

  # SUPPLEMENTAL STUFF HERE
  if type -path ethtool >/dev/null 2>&1
  then
    ifconfig | grep "flags=" | grep -v "lo:" | cut -f1 -d":" | while read -r ETH
    do
      fnBANNER " ETHTOOL ${ETH} (***)"
      echo "Found ${ETH}..."
      echo
      ${SUDO} ethtool -i "${ETH}"
      echo
      ${SUDO} ethtool "${ETH}"
      echo
    done
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
fnIFCONFIG()
{
  fnBANNER " IFCONFIG"
  ifconfig
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
fnARP_CACHE()
{
  fnBANNER " IP NEIGHBORS (ARP CACHE)"
  ip neigh
  echo
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
fnSUPPLICANT()
{
  if [[ -f /etc/wpa_supplicant/wpa_supplicant.conf ]]
  then
    fnBANNER " WPA_SUPPLICANT FILE (Passwords will not be displayed)"
    ${SUDO} cat /etc/wpa_supplicant/wpa_supplicant.conf 2>/dev/null | grep -v "^$" \
      | sed 's/psk=.*/psk=**PASSWORD_HIDDEN**/' \
      | sed 's/wep_key0=.*/wep_key0=**PASSWORD_HIDDEN**/' \
      | sed 's/password=.*/password=**PASSWORD_HIDDEN**/' \
      | sed 's/passwd=.*/passwd=**PASSWORD_HIDDEN**/'
    echo
  fi
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
fnIWCONFIG()
{
  local WLAN

  fnBANNER " IWCONFIG"
  ip -s link | grep "wlan[0-3]" | awk '{ print $2 }' | cut -f1 -d":" | while read -r WLAN
  do
    iwconfig "${WLAN}" 2>/dev/null
  done
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
fnWIFI_AP()
{
  fnBANNER " VISIBLE WIFI ACCESS POINTS"
  iwlist scan 2>/dev/null | grep -v "^$" | grep -v "Unknown:"
  echo
}

#---------------
# Called by fnGROUP_NETWORK
# Calls fnBANNER
fnNETSTAT()
{
  fnBANNER " NETSTAT"
  netstat -n 2>/dev/null
  echo
}

#---------------
# Called by fnGROUP_NET_FS
# Calls fnBANNER
fnRPC_NFS()
{
  local PS_RPC

  # SUPPLEMENTAL STUFF HERE
  # Another supplemental test.  If they have the portmapper and NFS running,
  # we'll show some information along with a list of any exports.
  PS_RPC=$(pgrep rpcbind)
  if [[ -n "${PS_RPC}" ]]
  then
    if type -path rpcinfo >/dev/null 2>&1
    then
      fnBANNER " PORTMAPPER - RPCINFO (***)"
      rpcinfo localhost
      echo
    else
      echo "Missing utility rpcinfo, skipping rpcinfo display" >&2
    fi

    #---------------
    # SUPPLEMENTAL STUFF HERE
    if type -path showmount >/dev/null 2>&1
    then
      fnBANNER " EXPORTED NFS DIRS (***)"
      showmount -e localhost
      echo
    else
      echo "Missing utility showmount, skipping nfs exports display" >&2
    fi

    #---------------
    # SUPPLEMENTAL STUFF HERE
    fnBANNER " MOUNTED NFS DIRS (***)"
    if [[ "$(df -hT --type=nfs --type=nfs4)" != "" ]]
    then
      df -hT --type=nfs --type=nfs4
      echo
      if type -path nfsiostat >/dev/null 2>&1 && type -path grep >/dev/null 2>&1
      then
        fnBANNER " NFSIOSTAT (***)" | grep -v "^$"
        nfsiostat
      else
        echo "Missing nfsiostat, skipping nfsiostat display" >&2
      fi
    else
      echo "No NFS shares mountted"
    fi
    echo
  fi
}

#---------------
# Called by fnGROUP_NET_FS
# Calls fnBANNER
fnSMB_CIFS()
{
  local PS_SMB

  # SUPPLEMENTAL STUFF HERE
  # Another supplemental test.  If they have smb running,
  # we'll show some samba stats
  PS_SMB=$(pgrep smbd)
  if [[ -n "${PS_SMB}" ]]
  then
    if type -path smbstatus >/dev/null 2>&1
    then
      fnBANNER " SMBSTATUS - REMOTE SYSTEMS CONNECTED TO US (***)" | grep -v "^$"
      ${SUDO} smbstatus
    else
      echo "Missing utility smbstatus, skipping smbstatus display" >&2
    fi
  fi

  fnBANNER " MOUNTED CIFS DIRS"
  if [[ -n "$(df -hT --type=cifs 2>/dev/null)" ]]
  then
    df -hT --type=cifs 2>/dev/null
  else
    echo "No remote CIFS/Windows shares mounted"
  fi
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
fnERRNO()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path perl >/dev/null 2>&1 && type -path m4 >/dev/null 2>&1
  then
    fnBANNER " OPERATING SYSTEM ERROR NUMBERS (***)"
    echo " NUM SYMBOLIC_NAME    DESCRIPTION"
    echo " ----------------------------------------------------"
    # Ordinarily the codes don't go as high as 255, but allowing for
    # such here is hoped to future-proof the command in the event
    # new error numbers appear with future releases of the kernel.
    # The following only prints valid errnos that exist in the kernel.
    perl -MErrno -e 'my %e= map { Errno->$_()=>$_ } keys(%!); print grep !/unknown error/i, map sprintf("%4d %-16s %s".$/,$_,$e{$_},$!=$_), 1..255'
    echo
  fi
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
fnSIGNALS()
{
  fnBANNER " EVENT SIGNALS"
  trap -l
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
fnCRON()
{
  fnBANNER " JOB SCHEDULING - CRON"
  echo " Contents of /etc/crontab:"
  if [[ -f /etc/crontab ]]
  then
    cat /etc/crontab
  else
    echo " File /etc/crontab is missing!"
  fi
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /etc/cron.d ..."
  ls /etc/cron.d
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /etc/cron.hourly ..."
  ls /etc/cron.hourly
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /etc/cron.daily ..."
  ls /etc/cron.daily
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /etc/cron.weekly ..."
  ls /etc/cron.weekly
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /etc/cron.monthly ..."
  ls /etc/cron.monthly
  echo
  echo " ----------------------------------------------------"
  echo " cron files in /var/spool/cron/crontabs:"
  ${SUDO} ls /var/spool/cron/crontabs
  echo
  echo " ----------------------------------------------------"
  echo " Contents of /etc/cron.allow:"
  if [[ -f /etc/cron.allow ]]
  then
    cat /etc/cron.allow
  else
    echo " File /etc/cron.allow not configured"
  fi
  echo
  echo " ----------------------------------------------------"
  echo " Contents of /etc/cron.deny:"
  if [[ -f /etc/cron.deny ]]
  then
    cat /etc/cron.deny
  else
    echo " File /etc/cron.deny not configured"
  fi
  echo
  echo " ----------------------------------------------------"
  systemctl status cron.service
  echo
}

#---------------
# Called by fnGROUP_OS_CONFIG
# Calls fnBANNER
fnAT()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path at >/dev/null 2>&1
  then
    fnBANNER " JOB SCHEDULING - AT (***)"
    if [[ -f /etc/at.allow ]]
    then
      echo " Contents of /etc/at.allow:"
      ${SUDO} cat /etc/at.allow 2>/dev/null
      echo
    else
      echo " File /etc/at.allow not configured"
      echo
    fi
    echo " ----------------------------------------------------"
    if [[ -f /etc/at.deny ]]
    then
      echo " Contents of /etc/at.deny:"
      ${SUDO} cat /etc/at.deny 2>/dev/null
      echo
    else
      echo " File /etc/at.deny not present"
      echo
    fi
    echo " ----------------------------------------------------"
    echo " at files in /var/spool/cron/atjobs:"
    ${SUDO} ls /var/spool/cron/atjobs
    echo
    echo " ----------------------------------------------------"
    echo " at files in /var/spool/cron/atspool:"
    ${SUDO} ls /var/spool/cron/atspool
    echo
    echo " ----------------------------------------------------"
    echo " Checking atq for any jobs..."
    if [[ -n "$(${SUDO} atq)" ]]
    then
      ${SUDO} atq
    else
      echo " No jobs found"
    fi
    echo
    echo " ----------------------------------------------------"
    systemctl status atd.service
    echo
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
fnSYSBENCH_CPU()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path sysbench >/dev/null 2>&1
  then
    fnBANNER " SYSBENCH CPU BENCHMARK (***)"
    sysbench --num-threads=4 --test=cpu --cpu-max-prime=20000 --validate run
    echo
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
fnSYSBENCH_MEM()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path sysbench >/dev/null 2>&1
  then
    fnBANNER " SYSBENCH MEMORY READ/WRITE BENCHMARK (***)"
    sysbench --test=memory run --memory-total-size=2G
    echo " ----------------------------------------------------"
    sysbench --test=memory run --memory-total-size=2G --memory-oper=read
    echo
  fi
}

#---------------
# Called by fnGROUP_PERFORMANCE
# Calls fnBANNER
fnSYSBENCH_IO()
{
  # SUPPLEMENTAL STUFF HERE
  # This only gets called if the touchfile "${HOME}/.system_info_io" exists
  if type -path sysbench >/dev/null 2>&1
  then
    fnBANNER " SYSBENCH FILEIO BENCHMARK (***)"
    if [[ -e "${HOME}/.system_info_io" ]]
    then
      echo -e " Touchfile \"${HOME}/.system_info_io\" detected."
      echo " Executing the sysbench File I/O benchmark."
      echo "=================================================="
      echo
      sysbench --test=fileio --file-total-size=2G prepare
      sysbench --test=fileio --file-total-size=2G --file-test-mode=rndrw --init-rng=on --max-time=300 --max-requests=0 run
      sysbench --test=fileio --file-total-size=2G cleanup
      echo
      echo "=================================================="
      echo " To prevent system_info from running this test,"
      echo " delete the touchfile with the following command:"
      echo "   rm ${HOME}/.system_info_io"
      echo
    else
      echo -e " Touchfile \"${HOME}/.system_info_io\" not detected."
      echo " Skipping sysbench File I/O benchmark."
      echo
      echo " To have system_info run this test, create the"
      echo " touchfile with the following command:"
      echo "   touch ${HOME}/.system_info_io"
      echo
      echo " To prevent system_info from running this test,"
      echo " delete the touchfile with the following command:"
      echo "   rm ${HOME}/.system_info_io"
      echo
      echo " Note that enabling this test creates, writes, reads"
      echo " and deletes 128 test files, 16Mb each (2GB total)."
      echo " Most people will NOT want to do that much writing to"
      echo " their wear-sensitive media (mainly SD cards and USB-"
      echo " attached SSD drives), on a regular basis."
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
fnMODULES()
{
  fnBANNER " LOADED MODULES"
  lsmod | head -1
  lsmod | sort | grep -v "Used by"
  echo
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
fnMOD_DETAILS()
{
  local MODULE

  fnBANNER " MODULE DETAILS"
  lsmod | awk '{ print $1 }' | grep -v "^Module" | sort | while read -r MODULE
  do
    echo "===================="
    modinfo "${MODULE}"
    echo
  done
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
fnSHOW_REPOS()
{
  local REPO

  fnBANNER " CONFIGURED REPOSITORIES"
  echo "The following binary repositories are configured..."
  grep --recursive --include '*.list' '^deb ' /etc/apt/sources.list /etc/apt/sources.list.d/ 2>/dev/null | while read -r REPO
  do
    echo "  ${REPO}"
  done
  echo
  echo "The following source repositories are configured..."
  grep --recursive --include '*.list' '^deb-src ' /etc/apt/sources.list /etc/apt/sources.list.d/ 2>/dev/null | while read -r REPO
  do
    echo "  ${REPO}"
  done
  echo
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
fnUPGRADABLES()
{
  fnBANNER " CHECKING REPOSITORIES"
  # confirm that we can connect to the internet...
  if ping www.yahoo.com -c 3 >/dev/null 2>&1
  then
    echo "This script will *NOT* upgrade any of your packages."
    echo "It will only see if package upgrades are available."
    echo "Any package updates listed here are your responsibility"
    echo "to upgrade.  This script makes no changes to your system."
    echo
    echo "Fetching available package lists from the repositories..."
    ${SUDO} apt update 2>/dev/null
    echo
    echo "Any available upgrades will appear here..."
    ${SUDO} apt list --upgradable 2>/dev/null
    echo
  else
    echo "Unable to reach the Internet.  Are you connected?"
    echo
  fi
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
fnDEPENDENCY_CHECK()
{
  fnBANNER " CHECK FOR BROKEN DEPENDENCIES"
  ${SUDO} apt-get check
  echo
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
fnON_HOLD()
{
  # Packages can be placed "on hold" to prevent upgrading a package
  # in question.  While on hold, apt, apt-get, dpkg, aptitude and so on
  # will all refuse to upgrade the on-hold package.  Here, we remind
  # the admin of any packages they may have placed "on hold".
  #
  # To place a package on hold to prevent upgrade:
  #   sudo apt-mark hold <package_name>
  # To release a package from hold to allow upgrade:
  #   sudo apt-mark unhold <package_name>
  # To view list of packages currently on hold:
  #   sudo dpkg --get-selections | grep "hold"
  fnBANNER " PACKAGES ON HOLD TO DISALLOW UPGRADE"
  if [[ "$(${SUDO} dpkg --get-selections | grep "hold$")" = "" ]]
  then
    echo "No packages placed on hold"
    echo
  else
    ${SUDO} dpkg --get-selections | grep "hold$"
  fi
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
fnPACKAGES()
{
  fnBANNER " INSTALLED PACKAGE LIST"
  dpkg -l 2>/dev/null | tee /dev/null
  echo
}

#---------------
# Called by fnGROUP_MODS_PKGS
# Calls fnBANNER
fnPKG_DETAILS()
{
  local PACKAGE

  fnBANNER " PACKAGE DETAILS"
  apt list 2>/dev/null | cut -f1 -d"/" | sort | while read -r PACKAGE
  do
    echo "===================="
    apt show "${PACKAGE}" 2>/dev/null
  done
}

#---------------
# Called by fnGROUP_OTHER
# Calls fnBANNER, fnSUB_BANNER
fnDOCKER()
{
  local SERVICE

  # SUPPLEMENTAL STUFF HERE
  if [[ -n "$(pgrep dockerd)" ]] || [[ -n "$(pgrep docker)" ]]
  then
    fnBANNER " DOCKER (***)"
    ${SUDO} docker version 2>/dev/null
    echo
    echo "-------------------------------"
    ${SUDO} docker info 2>/dev/null

    if [[ -f /etc/containerd/config.toml ]]
    then
      fnSUB_BANNER " Contents of /etc/containerd/config.toml"
      grep -v "^#\|^$" < /etc/containerd/config.toml
      echo
    fi

    systemctl | grep docker | awk '{ print $1 }' | while read -r SERVICE
    do
      fnSUB_BANNER " Docker Service..." | grep -v "^$"
      systemctl status "${SERVICE}"
    done
    echo

    fnSUB_BANNER " ALL CONTAINERS" | grep -v "^$"
    ${SUDO} docker ps -a 2>/dev/null
    echo
    fnSUB_BANNER " RUNNING CONTAINERS" | grep -v "^$"
    ${SUDO} docker ps 2>/dev/null
    echo
    fnSUB_BANNER " ALL IMAGES"
    ${SUDO} docker images 2>/dev/null
    echo

    if [[ "$(docker images 2>/dev/null | awk '{ print $1 }' | grep "^hello-world")" != "" ]]
    then
      fnSUB_BANNER " Docker \"Hello World\"" | grep -v "^$"
      ${SUDO} docker run --rm -it hello-world 2>/dev/null | sed 's/\r//'
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_OTHER
# Calls fnBANNER
fnNSPAWN()
{
  local NSPAWNPKG
  local NSPAWN

  # SUPPLEMENTAL STUFF HERE
  if [[ -n "$(pgrep systemd-nspawn)" ]]
  then
    fnBANNER " SYSTEMD-NSPAWN (***)"
    echo "NSPAWN-RELATED PACKAGES INSTALLED:"
    echo
    dpkg -l | grep -i nspawn | awk '{ print $2 }' | while read -r NSPAWNPKG
    do
      apt show "${NSPAWNPKG}" 2>/dev/null
      echo "-------------------------------"
      echo
    done
    echo "CONTAINERS FOUND IN: /var/lib/machines"
    ${SUDO} find /var/lib/machines/ -maxdepth 1 -mindepth 1 -type d -exec basename {} \;
    echo
    echo "-------------------------------"
    ${SUDO} systemctl list-machines
    echo
    machinectl list
    echo
    echo "-------------------------------"
    if type -path ds64-shell >/dev/null 2>&1
    then
      echo "DS64-SHELL..."
      ds64-shell --version 2>/dev/null | sed 's/\r//'
      echo
      echo "-------------------------------"
    fi
    systemctl | grep nspawn | awk '{ print $1 }' | while read -r NSPAWN
    do
      systemctl status "${NSPAWN}"
      echo
      echo "-------------------------------"
    done
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER, fnMOG
fnUSERCHECK()
{
  local PW_REC
  local PW_USR
  local PW_NUM
  local PW_GRP
  local GRP_GRP
  local HOMEDIR
  local GRP_REC

  fnBANNER " REGULAR (NON-SYSTEM) USER ACCOUNTS"
  sort -u -n -t: -k 3.1 /etc/passwd | while read -r PW_REC
  do
    PW_USR="$(echo "${PW_REC}" | cut -f1 -d":")"
    PW_NUM="$(echo "${PW_REC}" | cut -f3 -d":")"
    PW_GRP="$(echo "${PW_REC}" | cut -f4 -d":")"
    GRP_GRP="$(grep ":${PW_GRP}:" /etc/group | cut -f1 -d":")"
    if [[ "${PW_NUM}" -ge 1000 ]] && [[ "${PW_USR}" != "nobody" ]]
    then
      echo "--------------------"
      echo -n "USER NAME ................... "
      echo "${PW_USR}"

      echo -n "NUMERIC UID ................. "
      echo "${PW_REC}" | cut -f3 -d":"

      echo -n "USER'S PRIMARY GROUP ........ "
      grep ":${PW_GRP}:" /etc/group | cut -f1 -d":"

      echo -n "HOME DIRECTORY .............. "
      HOMEDIR=$(grep "^${PW_USR}:" /etc/passwd | cut -f6 -d":")
      if [[ -d "${HOMEDIR}" ]]
      then
        fnMOG 700 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}"
      else
        echo -n "${HOMEDIR}"
        echo " <-- *** WARNING: SPECIFIED DIRECTORY DOES NOT EXIST ***"
      fi

      echo -n "THE USER'S SHELL ............ "
      grep "^${PW_USR}:" /etc/passwd | cut -f7 -d":"

      echo -n "MEMBER OF GROUPS ............ "
      if [[ "$(grep "^${PW_USR}:\|:${PW_USR}$\|:${PW_USR},\|,{PW_USR},\|,${PW_USR}$" /etc/group | cut -f1 -d":" | head -1)" != "" ]]
      then
        grep "^${PW_USR}:\|:${PW_USR}$\|:${PW_USR},\|,{PW_USR},\|,${PW_USR}$" /etc/group | cut -f1 -d":" | sort | while read -r GRP_REC
        do
          echo -n "${GRP_REC} "
        done
        echo
      else
        echo "Account is not a member of any groups"
      fi

      echo -n "PASSWORD STATUS ............. "
      case "$(${SUDO} passwd --status "${PW_USR}" | awk '{ print $2 }')" in
        NP)
          echo "<-- *** NO PASSWORD (THIS IS BAD) ***"
          ;;
        L)
          echo "<-- *** ADMINISTRATIVELY LOCKED ***"
          ;;
        P)
          echo "VALID - OK"
          ;;
      esac

      echo -n "PASSWORD LAST CHANGED ....... "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -1
      echo -n "PASSWORD EXPIRES ............ "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -2 | tail -1
      echo -n "PASSWORD INACTIVE ........... "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -3 | tail -1
      echo -n "ACCOUNT EXPIRES ............. "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -4 | tail -1
      echo -n "MIN PASSWORD LIFE (DAYS) .... "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -5 | tail -1
      echo -n "MAX PASSWORD LIFE (DAYS) .... "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -6 | tail -1
      echo -n "WARN BEFORE CHANGE (DAYS) ... "
      ${SUDO} chage -l "${PW_USR}" | cut -f2 -d":" | sed 's/^ //' | head -7 | tail -1

      if [[ -d "${HOMEDIR}/.ssh" ]]
      then
        echo "USER'S .ssh SETUP:"
        fnMOG 700 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh"
        if [[ -f "${HOMEDIR}/.ssh/authorized_keys" ]]
        then
          fnMOG 600 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/authorized_keys"
        fi
        if [[ -f "${HOMEDIR}/.ssh/known_hosts" ]]
        then
          fnMOG 600 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/known_hosts"
        fi
        if [[ -f "${HOMEDIR}/.ssh/config" ]]
        then
          fnMOG 600 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/config"
        fi
        if [[ -f "${HOMEDIR}/.ssh/id_dsa" ]]
        then
          fnMOG 600 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/id_dsa"
        fi
        if [[ -f "${HOMEDIR}/.ssh/id_dsa.pub" ]]
        then
          fnMOG 644 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/id_dsa.pub"
        fi
        if [[ -f "${HOMEDIR}/.ssh/id_rsa" ]]
        then
          fnMOG 600 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/id_rsa"
        fi
        if [[ -f "${HOMEDIR}/.ssh/id_rsa.pub" ]]
        then
          fnMOG 644 "${PW_USR}" "${GRP_GRP}" "${HOMEDIR}/.ssh/id_rsa.pub"
        fi
      fi
    echo
    fi
  done
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
fnLOGIN_DEFS()
{
  fnBANNER " SYSTEM LOGIN DEFAULTS"
  grep -v "^$\|^#" /etc/login.defs
  echo
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER, fnSUB_BANNER
fnLAST_LOGINS()
{
  fnBANNER " LAST LOGINS"
  last
  echo
  lastlog
  echo
  fnSUB_BANNER " LOGIN FAILURES"
  ${SUDO} lastb
  echo
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
fnW()
{
  fnBANNER " CURRENTLY LOGGED ON"
  w
  echo
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
fnSUDOERS()
{
  fnBANNER " SUDOERS SYNTAX CHECK"
  ${SUDO} visudo --check --strict
  echo
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER, fnMOG
fnCHECK_PERMISSIONS()
{
  fnBANNER " CHECKING BASIC CRITICAL DIRECTORY PERMISSIONS"
  fnMOG 755 root root /
  fnMOG 755 root root /bin
  fnMOG 755 root root /boot
  fnMOG 755 root root /dev
  fnMOG 755 root root /etc
  fnMOG 755 root root /home
  fnMOG 755 root root /lib
  fnMOG 755 root root /media
  fnMOG 755 root root /mnt
  fnMOG 755 root root /opt
  fnMOG 555 root root /proc
  fnMOG 700 root root /root
  fnMOG 755 root root /run
  fnMOG 755 root root /sbin
  fnMOG 755 root root /srv
  fnMOG 555 root root /sys
  fnMOG 1777 root root /tmp
  fnMOG 755 root root /usr
  fnMOG 755 root root /var
  echo
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
fnCHKROOTKIT()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path chkrootkit >/dev/null 2>&1
  then
    fnBANNER " CHECKING FOR ROOTKITS - CHKROOTKIT (***)"
    ${SUDO} chkrootkit -e -n 2>/dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
fnCLAM()
{
  local CLAM_SVC

  # SUPPLEMENTAL STUFF HERE
  if type -path clamscan >/dev/null 2>&1
  then
    fnBANNER " CLAMAV ANTI-VIRUS SCANNER (***)"
    if type -path clamscan >/dev/null 2>&1
    then
      echo "CLAMSCAN.... $(clamscan --version 2>/dev/null)"
    else
      echo "CLAMSCAN.... not found"
    fi

    if type -path freshclam >/dev/null 2>&1
    then
      echo "FRESHCLAM... $(freshclam --version 2>/dev/null)"
    else
      echo "FRESHCLAM... not found"
    fi

    if type -path clamd >/dev/null 2>&1
    then
      echo "CLAMD....... $(clamd --version 2>/dev/null)"
    else
      echo "CLAMD....... not found"
    fi

    if type -path clamdscan >/dev/null 2>&1
    then
      echo "CLAMDSCAN... $(clamdscan --version 2>/dev/null)"
    else
      echo "CLAMDSCAN.... not found"
    fi

    echo

    if type -path clamconf >/dev/null 2>&1
    then
      echo " ----------------------------------------------------"
      clamconf -n 2>/dev/null
      echo
    fi

    if [[ "$(systemctl | grep clamav)" != "" ]]
    then
      systemctl | grep clamav | awk '{ print $1 }' | while read -r CLAM_SVC
      do
        echo " ----------------------------------------------------"
        systemctl status "${CLAM_SVC}"
        echo
      done
    else
      echo " ----------------------------------------------------"
      echo "No clamav-related systemd services running."
      echo
    fi
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
fnTRIPWIRE()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path tripwire >/dev/null 2>&1
  then
    fnBANNER " TRIPWIRE (***)"
    tripwire
    echo
    echo " ----------------------------------------------------"

    if [[ -f /etc/tripwire/tw.cfg ]]
    then
      echo -e " Default Config File ...... /etc/tripwire/tw.cfg"
    fi

    if [[ -f /etc/tripwire/tw.pol ]]
    then
      echo -e " Default Policy File ...... /etc/tripwire/tw.pol"
    fi

    if [[ -f /var/lib/tripwire/"${HOSTNAME}".twd ]]
    then
      echo -e " Default Database File .... /var/lib/tripwire/${HOSTNAME}.twd"
    fi

    if [[ -f /etc/tripwire/site.key ]]
    then
      echo -e " Default Site Key ......... /etc/tripwire/site.key"
    fi

    if [[ -f /etc/tripwire/"${HOSTNAME}"-local.key ]]
    then
      echo -e " Default Local Key ........ /etc/tripwire/${HOSTNAME}-local.key"
    fi

    if [[ -d /var/lib/tripwire/report ]]
    then
      echo -e " Default Report Directory . /var/lib/tripwire/report"
    fi

    echo " ----------------------------------------------------"
    echo
    if [[ -f /var/lib/tripwire/"${HOSTNAME}".twd ]]
    then
      ${SUDO} tripwire --check
    fi
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
fnNMAP()
{
  local MY_IP

  # SUPPLEMENTAL STUFF HERE
  # Not everyone has, or needs, nmap.  So, it's not a required dependency
  # for this script.  However, if we do find that it is available, we can
  # make use of it here.
  if type -path nmap >/dev/null 2>&1
  then
    # IPV4
    ifconfig | grep "inet " | awk '{ print $2 }' | sort -u -n -t. -k 1,1  -k 2,2  -k 3,3  -k 4,4 | while read -r MY_IP
    do
      fnBANNER " SCANNING FOR SERVICES ON IPV4: ${MY_IP} (***)"
      nmap -Pn -sV -T4 -p 1-65535 --version-light "${MY_IP}" | grep "^PORT\|^[1-9][0-9]"
      echo
    done
    # IPV6
    ifconfig | grep "inet6 " | grep -v "inet6 ....::" | awk '{ print $2 }' | sort | while read -r MY_IP
    do
      fnBANNER " SCANNING FOR SERVICES ON IPV6: ${MY_IP} (***)"
      nmap -6 -Pn -sV -T4 -p 1-65535 --version-light "${MY_IP}" | grep "^PORT\|^[1-9][0-9]"
      echo
    done
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER, fnSUB_BANNER
fnSNORT()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path snort >/dev/null 2>&1
  then
    fnBANNER " SNORT IDS (***)"
    snort -V 2>&1
    echo
    if [[ -f /etc/snort/snort.conf ]]
    then
      fnSUB_BANNER " SNORT CONFIGURATION TEST..."
      ${SUDO} snort -T -c /etc/snort/snort.conf 2>&1
      echo
    fi
    echo " ----------------------------------------------------"
    systemctl status snort.service
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
fnLYNIS()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path lynis >/dev/null 2>&1
  then
    fnBANNER " LYNIS (***)"
    ${SUDO} lynis update info --cronjob 2> /dev/null
    echo " ----------------------------------------------------"
    ${SUDO} lynis update check --cronjob 2> /dev/null
    echo
    echo " ----------------------------------------------------"
    ${SUDO} lynis show profiles --cronjob 2> /dev/null
    echo
    echo " ----------------------------------------------------"
    ${SUDO} lynis audit system --cronjob 2> /dev/null
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
fnUFW()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path ufw >/dev/null 2>&1
  then
    fnBANNER " UFW (***)"
    ${SUDO} ufw version
    echo
    echo " ----------------------------------------------------"
    ${SUDO} ufw status verbose
    echo
    echo " ----------------------------------------------------"
    systemctl status ufw.service
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
fnRKHUNTER()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path rkhunter >/dev/null 2>&1
  then
    fnBANNER " CHECKING FOR ROOTKITS - RKHUNTER (***)"
    ${SUDO} rkhunter --versioncheck --nocolors
    echo
    echo " ----------------------------------------------------"
    ${SUDO} rkhunter --update --nocolors
    echo
    echo " ----------------------------------------------------"
    ${SUDO} rkhunter --config-check && ${SUDO} rkhunter -c --enable all --rwo --sk --nocolors ; echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
fnUNHIDE()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path unhide >/dev/null 2>&1
  then
    fnBANNER " UNHIDE (***)"
    ${SUDO} unhide sys
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
fnAUDITD()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path auditctl >/dev/null 2>&1 && [[ "${HAS_AUDITD}" = "yes" ]]
  then
    fnBANNER " AUDITD (***)"
    ${SUDO} auditctl -l
    echo
    echo " ----------------------------------------------------"
    ${SUDO} ls -alR /etc/audit
    echo
    echo " ----------------------------------------------------"
    ${SUDO} aureport
    echo
    echo " ----------------------------------------------------"
    ${SUDO} ls -alR /var/log/audit
    echo
    echo " ----------------------------------------------------"
    systemctl status auditd.service
    echo
  fi
}

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
# This function is an optimistic placeholder, should the
# kernel one day be provided with SELINUX support compiled in.
# It presently does nothing but return to where it was called.
# fnSELINUX()
# {
#   # SUPPLEMENTAL STUFF HERE
#   if [[ "${HAS_SELINUX}" = "yes" ]]
#   then
#     fnBANNER " SELINUX (***)"
#   fi
# }

#---------------
# Called by fnGROUP_SECURITY
# Calls fnBANNER
fnAPPARMOR()
{
  # SUPPLEMENTAL STUFF HERE
  if type -path aa-status >/dev/null 2>&1 && [[ "${HAS_APPARMOR}" = "yes" ]] && [[ "$(grep "apparmor=1" /boot/cmdline.txt)" != "" ]]
  then
    fnBANNER " APPARMOR (***)"
    echo -n "Apparmor enabled: "
    aa-enabled
    echo
    ${SUDO} aa-status
    echo
  fi
}

#----------------------------------- INITIALIZATION - RUN BEFORE MENU
# Called by fnMAIN
# Calls several functions
fnCONFIRM_PREREQS()
{
  fnSUDO
  fnCONFIRM_OS
  fnRING_BUF
  fnCHECK_VIRT
  fnCHECK_CHROOT
  fnDECODE_REV
  fnCHK_PACKAGES
  fnLSHW_BUSINFO
}

##################################################
# THE INDIVIDUAL FUNCTIONS DEFINED ABOVE NOW GET GROUPED TOGETHER
# BY MENU SELECTION.
#
# Defining all of the above as descrete functions makes it easy to now
# group related functions together by menu selection.  It beats
# moving whole blocks of code around.

#----------------------------------- Pi Hardware
# Called by fnACTIONS
# Calls several functions
fnGROUP_HARDWARE()
{
  echo ' __ __ _____  __                '
  echo '(_ |_ /   | |/  \|\ |   /|      Menu Option 1'
  echo '__)|__\__ | |\__/| \|    |      PI HARDWARE'
  echo
  MENU_OPTION="(1)"
  fnPRINT_DECODED_REV
  fnSYSTEM_ID
  fnMAC
  fnMODEL
  fnDIAGRAM
  fnCPU
  fnSENSORS
  fnHOW_BOOT
}

#----------------------------------- Performance
# Called by fnACTIONS
# Calls several functions
fnGROUP_PERFORMANCE()
{
  echo ' __ __ _____  __        __      '
  echo '(_ |_ /   | |/  \|\ |    _)     Menu Option 2'
  echo '__)|__\__ | |\__/| \|   /__     PERFORMANCE'
  echo
  MENU_OPTION="(2)"
  fnPROCSPEED
  fnOVERCLOCK
  fnRING_OSCILLATOR
  fnCLOCKFREQ
  fnVOLTS
  fnTEMPS
  fnGOV
  fnTHROTTLES
  fnMPSTAT
  fnIOSTAT
  fnSYSBENCH_CPU
  fnSYSBENCH_MEM
  fnSYSBENCH_IO
}

#----------------------------------- O/S Config
# Called by fnACTIONS
# Calls several functions
fnGROUP_OS_CONFIG()
{
  echo ' __ __ _____  __        __      '
  echo '(_ |_ /   | |/  \|\ |    _)     Menu Option 3'
  echo '__)|__\__ | |\__/| \|   __)     OS CONFIG'
  echo
  MENU_OPTION="(3)"
  fnOS
  fnLOCALE
  fnCMDLINE
  fnCONFIGTXT
  fnDTOVERLAYS
  fnDTPARAMS
  fnSYSCTL
  fnLEDS
  fnULIMIT_CORE
  fnERRNO
  fnSIGNALS
  fnCRON
  fnAT
}

#----------------------------------- Memory
# Called by fnACTIONS
# Calls several functions
fnGROUP_MEMORY()
{
  echo ' __ __ _____  __                '
  echo '(_ |_ /   | |/  \|\ |   |__|    Menu Option 4'
  echo '__)|__\__ | |\__/| \|      |    MEMORY'
  echo
  MENU_OPTION="(4)"
  fnMEMSPLIT
  fnMEMSWAP
  fnMEMINFO
  fnIPC
}

#----------------------------------- Logging
# Called by fnACTIONS
# Calls several functions
fnGROUP_LOGGING()
{
  echo ' __ __ _____  __         __     '
  echo '(_ |_ /   | |/  \|\ |   |_      Menu Option 5'
  echo '__)|__\__ | |\__/| \|   __)     LOGGING'
  echo
  MENU_OPTION="(5)"
  fnDMESG
  fnJOURNAL
  fnRSYSLOG
  fnLOGROTATE
}

#----------------------------------- Services
# Called by fnACTIONS
# Calls several functions
fnGROUP_OS_SERVICES()
{
  echo ' __ __ _____  __         __     '
  echo '(_ |_ /   | |/  \|\ |   /__     Menu Option 6'
  echo '__)|__\__ | |\__/| \|   \__)    SERVICES'
  echo
  MENU_OPTION="(6)"
  fnSYSTEMD_CHAIN
  fnSYSTEMD_BLAME
  fnSYSCTL_STATUS
  fnSYSCTL_FAIL
  fnSYSCTL_LIST
  fnRCLOCAL
}

#----------------------------------- H/W Busses
# Called by fnACTIONS
# Calls several functions
fnGROUP_HW_BUSSES()
{
  echo ' __ __ _____  __        ___     '
  echo '(_ |_ /   | |/  \|\ |     /     Menu Option 7'
  echo '__)|__\__ | |\__/| \|    /      HARDWARE BUSSES'
  echo
  MENU_OPTION="(7)"
  fn1W
  fnSPI
  fnI2S
  fnI2C
  fnWIRINGPI
  fnPIGPIOD
}

#----------------------------------- Serial & Bluetooth
# Called by fnACTIONS
# Calls several functions
fnGROUP_SERIAL_BT()
{
  echo ' __ __ _____  __         __     '
  echo '(_ |_ /   | |/  \|\ |   (__)    Menu Option 8'
  echo '__)|__\__ | |\__/| \|   (__)    SERIAL & BLUETOOTH'
  echo
  MENU_OPTION="(8)"
  fnACM
  fnSERIAL
  fnBT
}

#----------------------------------- USB & Other Devices
# Called by fnACTIONS
# Calls several functions
fnGROUP_DEVICES()
{
  echo ' __ __ _____  __         __     '
  echo '(_ |_ /   | |/  \|\ |   (__\    Menu Option 9'
  echo '__)|__\__ | |\__/| \|    __/    USB & OTHER DEVICES'
  echo
  MENU_OPTION="(9)"
  fnUSB_DEV_INFO
  fnLSHW_INPUT
  fnLSHW_GENERIC
  fnRTL_SDR
  fnRTC
  fnHWRNG
  fnHWWD
  fnLIRC
  fnPRINTER
}

#----------------------------------- Filesystems & Storage
# Called by fnACTIONS
# Calls several functions
fnGROUP_FS_STORAGE()
{
  echo ' __ __ _____  __            __  '
  echo '(_ |_ /   | |/  \|\ |   /| /  \ Menu Option 10'
  echo '__)|__\__ | |\__/| \|    | \__/ FILESYSTEMS & STORAGE'
  echo
  MENU_OPTION="(10)"
  fnFSTAB
  fnLSHW_STORAGE
  fnHDPARM
  fnSMART
  fnQUIRKS
  fnTRIM
  fnBLKID
  fnRAID
  fnLVM
  fnQUOTAS
  fnOVERLAYFS
}

#----------------------------------- Audio & Video
# Called by fnACTIONS
# Calls several functions
fnGROUP_AV()
{
  echo ' __ __ _____  __                '
  echo '(_ |_ /   | |/  \|\ |   /| /|   Menu Option 11'
  echo '__)|__\__ | |\__/| \|    |  |   AUDIO & VIDEO'
  echo
  MENU_OPTION="(11)"
  fnLSHW_MM
  fnALSA_MOD
  fnALSA_HW
  fnALSA_CARD
  fnALSA_PB_CAP
  fnCAMERA
  fnCODECS
  fnV4L2CODECS
  fnV4LDEV
  fnTOUCH
  fnDISPDRV
  fnDISPLAY
  fnROWS_COLS
  fnRESOLUTION
  fnXRESOLUTION
}

#----------------------------------- Networking
# Called by fnACTIONS
# Calls several functions
fnGROUP_NETWORK()
{
  echo ' __ __ _____  __           __   '
  echo '(_ |_ /   | |/  \|\ |   /|  _)  Menu Option 12'
  echo '__)|__\__ | |\__/| \|    | /__  NETWORKING'
  echo
  MENU_OPTION="(12)"
  fnIP6STAT
  fnNET_FILES
  fnROUTES
  fnNET_ADAPTERS
  fnETHTOOL
  fnIFCONFIG
  fnARP_CACHE
  fnSUPPLICANT
  fnIWCONFIG
  fnWIFI_AP
  fnNETSTAT
}

#----------------------------------- Network Filesystems
# Called by fnACTIONS
# Calls several functions
fnGROUP_NET_FS()
{
  echo ' __ __ _____  __           __   '
  echo '(_ |_ /   | |/  \|\ |   /|  _)  Menu Option 13'
  echo '__)|__\__ | |\__/| \|    | __)  NETWORK FILESYSTEMS'
  echo
  MENU_OPTION="(13)"
  fnRPC_NFS
  fnSMB_CIFS
}

#----------------------------------- Containers & Virtualization
# Called by fnACTIONS
# Calls several functions
fnGROUP_OTHER()
{
  echo ' __ __ _____  __                '
  echo '(_ |_ /   | |/  \|\ |   /| |__| Menu Option 14'
  echo '__)|__\__ | |\__/| \|    |    | CONTAINERS & VIRTUALIZATION'
  echo
  MENU_OPTION="(14)"
  fnDOCKER
  fnNSPAWN
}

#----------------------------------- Modules and Packages
# Called by fnACTIONS
# Calls several functions
fnGROUP_MODS_PKGS()
{
  echo ' __ __ _____  __            __  '
  echo '(_ |_ /   | |/  \|\ |   /| |_   Menu Option 15'
  echo '__)|__\__ | |\__/| \|    | __)  MODULES AND PACKAGES'
  echo
  MENU_OPTION="(15)"
  fnMODULES
  # This next function generates information about each loaded module listed
  # by fnMODULES, above.  The amount of information can be significant,
  # depending upon how many modules are running.  Uncomment if you'ld like,
  # but it may give more information than you are willing to scroll through.
  # fnMOD_DETAILS

  fnSHOW_REPOS
  fnUPGRADABLES
  fnDEPENDENCY_CHECK
  fnON_HOLD
  fnPACKAGES
  # This next function will likely never see the light of day.  It generates
  # information about every installed package on a system.  You're better
  # off running "apt show" against a single package of interest only, than
  # having this script loop through every package.  (You could have thousands
  # of packages installed, and this would loop through every one of them!)
  # fnPKG_DETAILS
}

#----------------------------------- Security
# Called by fnACTIONS
# Calls several functions
fnGROUP_SECURITY()
{
  echo ' __ __ _____  __            __  '
  echo '(_ |_ /   | |/  \|\ |   /| /__  Menu Option 16'
  echo '__)|__\__ | |\__/| \|    | \__) SYSTEM SECURITY'
  echo
  MENU_OPTION="(16)"
  fnUSERCHECK
  fnLOGIN_DEFS
  fnLAST_LOGINS
  fnW
  fnSUDOERS
  fnCHECK_PERMISSIONS
  fnCHKROOTKIT
  fnRKHUNTER
  fnCLAM
  fnTRIPWIRE
  fnNMAP
  fnUFW
  fnSNORT
  fnLYNIS
  fnUNHIDE
# fnSELINUX
  fnAPPARMOR
  fnAUDITD
}

#---------------
# Called by fnFINISH_UP
fnEND_OF_REPORT()
{
  echo
  echo "==============================================================================="
  echo ' __     __    __  __   __  __ __  __  __ ___ '
  echo '|_ |\ ||  \  /  \|_   |__)|_ |__)/  \|__) |  '
  echo '|__| \||__/  \__/|    | \ |__|   \__/| \  |  '
  echo
}

##################################################
# HERE, WE ACTUALLY CALL THE GROUPS ABOVE, WHEN THE
# REPORT IS RUN, DEPENDING ON YOUR MENU SELECTIONS
#---------------
# Called by fnDO_INSPECTIONS
# Calls several functions
fnACTIONS()
{
  if [[ ${CHOICES[16]} ]]
  then
    fnGROUP_HARDWARE
    fnGROUP_PERFORMANCE
    fnGROUP_OS_CONFIG
    fnGROUP_MEMORY
    fnGROUP_LOGGING
    fnGROUP_OS_SERVICES
    fnGROUP_HW_BUSSES
    fnGROUP_SERIAL_BT
    fnGROUP_DEVICES
    fnGROUP_FS_STORAGE
    fnGROUP_AV
    fnGROUP_NETWORK
    fnGROUP_NET_FS
    fnGROUP_OTHER
    fnGROUP_MODS_PKGS
    fnGROUP_SECURITY
    # If user selects to do all, do all only once
    return
  fi
  if [[ ${CHOICES[0]} ]]
  then
    fnGROUP_HARDWARE
  fi
  if [[ ${CHOICES[1]} ]]
  then
    fnGROUP_PERFORMANCE
  fi
  if [[ ${CHOICES[2]} ]]
  then
    fnGROUP_OS_CONFIG
  fi
  if [[ ${CHOICES[3]} ]]
  then
    fnGROUP_MEMORY
  fi
  if [[ ${CHOICES[4]} ]]
  then
    fnGROUP_LOGGING
  fi
  if [[ ${CHOICES[5]} ]]
  then
    fnGROUP_OS_SERVICES
  fi
  if [[ ${CHOICES[6]} ]]
  then
    fnGROUP_HW_BUSSES
  fi
  if [[ ${CHOICES[7]} ]]
  then
    fnGROUP_SERIAL_BT
  fi
  if [[ ${CHOICES[8]} ]]
  then
    fnGROUP_DEVICES
  fi
  if [[ ${CHOICES[9]} ]]
  then
    fnGROUP_FS_STORAGE
  fi
  if [[ ${CHOICES[10]} ]]
  then
    fnGROUP_AV
  fi
  if [[ ${CHOICES[11]} ]]
  then
    fnGROUP_NETWORK
  fi
  if [[ ${CHOICES[12]} ]]
  then
    fnGROUP_NET_FS
  fi
  if [[ ${CHOICES[13]} ]]
  then
    fnGROUP_OTHER
  fi
  if [[ ${CHOICES[14]} ]]
  then
    fnGROUP_MODS_PKGS
  fi
  if [[ ${CHOICES[15]} ]]
  then
    fnGROUP_SECURITY
  fi
}

##################################################
# A FEW REMAINING SUPPORTING FUNCTIONS DEALING
# WITH THE REPORT, THE SAVING/RECALLING OF MENU
# SELECTIONS, ETC.
#---------------
# Called by fnDO_INSPECTIONS and fnFINISH_UP
fnREPORT_ACTIONS()
{
  local CHOICE_MADE

  echo "The following Menu Options were selected, to generate this report:"
  echo
  if [[ ${CHOICES[16]} ]]
  then
    echo "  Option 17: Run All Sections - (This option overrides any/all other selections)"
    echo
    return
  fi
  if [[ ${CHOICES[0]} ]]
  then
    echo "  Option  1: Pi Hardware"
    CHOICE_MADE="Y"
  fi
  if [[ ${CHOICES[1]} ]]
  then
    echo "  Option  2: Performance"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ ${CHOICES[2]} ]]
  then
    echo "  Option  3: O/S Config"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ ${CHOICES[3]} ]]
  then
    echo "  Option  4: Memory"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ ${CHOICES[4]} ]]
  then
    echo "  Option  5: Logging"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ ${CHOICES[5]} ]]
  then
    echo "  Option  6: Services"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ ${CHOICES[6]} ]]
  then
    echo "  Option  7: Hardware Busses"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ ${CHOICES[7]} ]]
  then
    echo "  Option  8: Serial & Bluetooth"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ ${CHOICES[8]} ]]
  then
    echo "  Option  9: USB & Other Devices"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ ${CHOICES[9]} ]]
  then
    echo "  Option 10: Filesystems & Storage"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ ${CHOICES[10]} ]]
  then
    echo "  Option 11: Audio & Video"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ ${CHOICES[11]} ]]
  then
    echo "  Option 12: Networking"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ ${CHOICES[12]} ]]
  then
    echo "  Option 13: Network Filesystems"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ ${CHOICES[13]} ]]
  then
    echo "  Option 14: Containers & Virtualization"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ ${CHOICES[14]} ]]
  then
    echo "  Option 15: Modules and Packages"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ ${CHOICES[15]} ]]
  then
    echo "  Option 16: Security"
    CHOICE_MADE="${CHOICE_MADE}Y"
  fi
  if [[ "$(echo "${CHOICE_MADE}" | grep "Y")" = "" ]]
  then
    echo "  No Menu Options were selected"
  fi
  echo
}

#---------------
# Called by fnCHECK_CMDLINE
fnREAD_RCFILE()
{
  local NUM
  local BOOLEAN

  # NOTE:  Because the array is 0-16, and the menu is presented as
  # options 1-17, the keys in the rc file are 1 lower than the menu
  # numbers they represent.  For example, menu option 1 is stored as
  # a key of 0, option 2 is stored as a key of 1, and so on.

  # RCFILE format is:
  #   menu option number (minus 1), a colon (:), and a boolean (0 or 1)
  #   0=not selected
  #   1=selected
  #
  #   example...
  #   0:1
  #   1:0
  #   2:0
  #   3:1
  #   ...
  #   17:0
  #
  #   The numeric options described above are then followed by flags
  #   that tell the script whether to run specific tests (or not), in
  #   the presence of the relevent supplemental packages.  For example,
  #   a user may have tripwire installed and configured, but may not
  #   want this script to perform a "tripwire --check".
  if [[ -f "${RCFILE}" ]]
  then
    # Numeric menu options
    for NUM in "${!OPTIONS[@]}"
    do
      BOOLEAN="$(grep "^${NUM}:" "${RCFILE}" 2>/dev/null | cut -f2 -d":")"
      if [[ "${BOOLEAN}" = "1" ]]
      then
        CHOICES[NUM]="${REV}+${SGR0}"
      fi
    done
  fi
}

#---------------
# Called by fnFINISH_UP
fnWRITE_RCFILE()
{
  local NUM

  for NUM in "${!OPTIONS[@]}"
  do
    if [[ "${CHOICES[NUM]}" ]]
    then
      echo "${NUM}:1"
    else
      echo "${NUM}:0"
    fi
  done
}

#---------------
# Called by fnFINISH_UP
fnREPORT_RCFILE()
{
  echo "These menu selections have been saved in the file:"
  echo "  ${RCFILE}"
  echo
  echo "They will be auto-selected next time this script is run by user \"$(whoami)\"."
  echo
}

#---------------
# Menu function
# Called by fnMAIN_LOOP
fnMENU()
{
  local SCR_ROW
  local SCR_COL

  echo "RASPBERRY PI SYSTEM INFORMATION REPORT v${MY_VERSION} - MAIN MENU"
  SCR_ROW=2
  SCR_COL=2
  for NUM in "${!OPTIONS[@]}"
  do
    if [[ "${SCR_ROW}" -gt 10 ]]
    then
      SCR_ROW=2
      SCR_COL=38
    fi
    tput cup ${SCR_ROW} ${SCR_COL} 2>/dev/null
    echo "[""${CHOICES[NUM]:- }""]" $(( NUM+1 ))") ${OPTIONS[NUM]}"
    (( SCR_ROW++ ))
  done
  (( SCR_ROW++ ))
  tput cup "${SCR_ROW}" 0 2>/dev/null
  echo "${ERROR}"
  echo "Type a number and press [ENTER] to select.  Again, to deselect."
  echo "Multiple selections can be made before any tests are executed."
}

#---------------
# Called by fnMAIN
# Calls fnREAD_RCFILE
fnCHECK_CMDLINE()
{

  # Force the execution of a specific menu selection when testing.
  # Make sure any parameter is numeric, and between 1 and 17.
  MY_PARAM="${MY_ARG}"
  if [[ ${MY_PARAM} = *[[:digit:]]* ]] && [[ "${MY_PARAM}" -ge 1 ]] && [[ "${MY_PARAM}" -le 17 ]] 2>/dev/null
  then
    # Align a 1-17 parameter with 0-16 array elements
    ((MY_PARAM=MY_PARAM-1))
    CHOICES[${MY_PARAM}]="${REV}+${SGR0}"
  else
    fnREAD_RCFILE
  fi
}

#---------------
# Called by fnMAIN
# Calls fnMENU
fnMAIN_LOOP()
{
  local SELECTION

  # Main Menu loop
  while fnMENU && read -r -e -p "Press [ENTER] by itself when ready.  Use Q [ENTER] or Ctrl-C to quit: " -n3 SELECTION && [[ -n "${SELECTION}" ]]
  do
    clear 2>/dev/null
    if [[ "${SELECTION}" = *[[:digit:]]* && ${SELECTION} -ge 1 && ${SELECTION} -le ${#OPTIONS[@]} ]]
    then
      (( SELECTION-- ))
      if [[ "${CHOICES[SELECTION]:-}" = "${REV}+${SGR0}" ]]
      then
        CHOICES[SELECTION]=""
      else
        CHOICES[SELECTION]="${REV}+${SGR0}"
      fi
      ERROR=" "
    else
      if [[ "${SELECTION}" = "q" ]] || [[ "${SELECTION}" = "Q" ]]
      then
        exit
      else
        ERROR="Invalid option: ${SELECTION}"
      fi
    fi
  done
}

#---------------
# Called by fnMAIN
# Calls several functions
fnDO_INSPECTIONS()
{
  local STAMP

  # Call all the inspections selected.
  clear 2>/dev/null
  STAMP=$(date +%F-%T | sed 's/:/-/g')
  REPORT=~/${HOSTNAME}-system_info-${STAMP}
  SECONDS=0
  true > "${REPORT}"
  fnTITLE | tee -a "${REPORT}"
  fnREPORT_ACTIONS | sed 's/\r//' | tee -a "${REPORT}"
  fnACTIONS | tee -a "${REPORT}"
}

#---------------
# Called by fnMAIN
# Calls several functions
fnFINISH_UP()
{
  local ELAPSED
  local RUNTIME

  # Closing Screen
  # Everything from here down happens after the inspections are complete.
  rm /tmp/.lshw_businfo.${PPID} 2>/dev/null
  ELAPSED=${SECONDS}
  RUNTIME="$((ELAPSED / 60)) minutes and $((ELAPSED % 60)) seconds."
  fnEND_OF_REPORT | tee -a "${REPORT}"
  fnBANNER " TIME REQUIRED TO GENERATE REPORT:  ${RUNTIME}" | tee -a "${REPORT}"
  fnREPORT_ACTIONS | sed 's/\r//' | tee -a "${REPORT}"
  if [[ "${MY_PARAM}" = "" ]]
  then
    fnWRITE_RCFILE > "${RCFILE}"
    fnREPORT_RCFILE | tee -a "${REPORT}"
  fi
  fnBANNER " REPORT SAVED AS: ${REPORT}" | tee -a "${REPORT}"
  echo "${BELL}"
}

#---------------
# Called by the mainline, below
# Calls several functions
fnMAIN()
{
  clear 2>/dev/null
  fnINITIALIZE
  fnCONFIRM_BASH
  fnTITLE
  fnCONFIRM_PREREQS
  fnDEFINE_OPTIONS
  echo -n "PRESS ENTER FOR MENU... "
  read -r FOO
  # This next line just quiets shellcheck's complaints
  # that variable FOO (above) is unused.  :/
  echo "${FOO}" >/dev/null
  clear 2>/dev/null
  fnCHECK_CMDLINE
  fnMAIN_LOOP
  fnDO_INSPECTIONS
  fnFINISH_UP
}

##################################################
# MAINLINE
##################################################

readonly MY_ARG=${1:-}
readonly MY_VERSION="1.9.6"

fnMAIN
